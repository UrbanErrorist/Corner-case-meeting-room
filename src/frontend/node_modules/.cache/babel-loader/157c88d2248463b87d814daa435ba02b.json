{"ast":null,"code":"/* eslint consistent-this: 0, no-shadow:0, no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */\n// Support for asynchronous functions\n\"use strict\";\n\nvar aFrom = require(\"es5-ext/array/from\"),\n    objectMap = require(\"es5-ext/object/map\"),\n    mixin = require(\"es5-ext/object/mixin\"),\n    defineLength = require(\"es5-ext/function/_define-length\"),\n    nextTick = require(\"next-tick\");\n\nvar slice = Array.prototype.slice,\n    apply = Function.prototype.apply,\n    create = Object.create;\n\nrequire(\"../lib/registered-extensions\").async = function (tbi, conf) {\n  var waiting = create(null),\n      cache = create(null),\n      base = conf.memoized,\n      original = conf.original,\n      currentCallback,\n      currentContext,\n      currentArgs; // Initial\n\n  conf.memoized = defineLength(function (arg) {\n    var args = arguments,\n        last = args[args.length - 1];\n\n    if (typeof last === \"function\") {\n      currentCallback = last;\n      args = slice.call(args, 0, -1);\n    }\n\n    return base.apply(currentContext = this, currentArgs = args);\n  }, base);\n\n  try {\n    mixin(conf.memoized, base);\n  } catch (ignore) {} // From cache (sync)\n\n\n  conf.on(\"get\", function (id) {\n    var cb, context, args;\n    if (!currentCallback) return; // Unresolved\n\n    if (waiting[id]) {\n      if (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback];else waiting[id].push(currentCallback);\n      currentCallback = null;\n      return;\n    } // Resolved, assure next tick invocation\n\n\n    cb = currentCallback;\n    context = currentContext;\n    args = currentArgs;\n    currentCallback = currentContext = currentArgs = null;\n    nextTick(function () {\n      var data;\n\n      if (hasOwnProperty.call(cache, id)) {\n        data = cache[id];\n        conf.emit(\"getasync\", id, args, context);\n        apply.call(cb, data.context, data.args);\n      } else {\n        // Purged in a meantime, we shouldn't rely on cached value, recall\n        currentCallback = cb;\n        currentContext = context;\n        currentArgs = args;\n        base.apply(context, args);\n      }\n    });\n  }); // Not from cache\n\n  conf.original = function () {\n    var args, cb, origCb, result;\n    if (!currentCallback) return apply.call(original, this, arguments);\n    args = aFrom(arguments);\n\n    cb = function self(err) {\n      var cb,\n          args,\n          id = self.id;\n\n      if (id == null) {\n        // Shouldn't happen, means async callback was called sync way\n        nextTick(apply.bind(self, this, arguments));\n        return undefined;\n      }\n\n      delete self.id;\n      cb = waiting[id];\n      delete waiting[id];\n\n      if (!cb) {\n        // Already processed,\n        // outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n        return undefined;\n      }\n\n      args = aFrom(arguments);\n\n      if (conf.has(id)) {\n        if (err) {\n          conf.delete(id);\n        } else {\n          cache[id] = {\n            context: this,\n            args: args\n          };\n          conf.emit(\"setasync\", id, typeof cb === \"function\" ? 1 : cb.length);\n        }\n      }\n\n      if (typeof cb === \"function\") {\n        result = apply.call(cb, this, args);\n      } else {\n        cb.forEach(function (cb) {\n          result = apply.call(cb, this, args);\n        }, this);\n      }\n\n      return result;\n    };\n\n    origCb = currentCallback;\n    currentCallback = currentContext = currentArgs = null;\n    args.push(cb);\n    result = apply.call(original, this, args);\n    cb.cb = origCb;\n    currentCallback = cb;\n    return result;\n  }; // After not from cache call\n\n\n  conf.on(\"set\", function (id) {\n    if (!currentCallback) {\n      conf.delete(id);\n      return;\n    }\n\n    if (waiting[id]) {\n      // Race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n      if (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback.cb];else waiting[id].push(currentCallback.cb);\n    } else {\n      waiting[id] = currentCallback.cb;\n    }\n\n    delete currentCallback.cb;\n    currentCallback.id = id;\n    currentCallback = null;\n  }); // On delete\n\n  conf.on(\"delete\", function (id) {\n    var result; // If false, we don't have value yet, so we assume that intention is not\n    // to memoize this call. After value is obtained we don't cache it but\n    // gracefully pass to callback\n\n    if (hasOwnProperty.call(waiting, id)) return;\n    if (!cache[id]) return;\n    result = cache[id];\n    delete cache[id];\n    conf.emit(\"deleteasync\", id, slice.call(result.args, 1));\n  }); // On clear\n\n  conf.on(\"clear\", function () {\n    var oldCache = cache;\n    cache = create(null);\n    conf.emit(\"clearasync\", objectMap(oldCache, function (data) {\n      return slice.call(data.args, 1);\n    }));\n  });\n};","map":{"version":3,"sources":["/Users/blackhat/Desktop/testingRoom/src/frontend/node_modules/memoizee/ext/async.js"],"names":["aFrom","require","objectMap","mixin","defineLength","nextTick","slice","Array","prototype","apply","Function","create","Object","async","tbi","conf","waiting","cache","base","memoized","original","currentCallback","currentContext","currentArgs","arg","args","arguments","last","length","call","ignore","on","id","cb","context","push","data","hasOwnProperty","emit","origCb","result","self","err","bind","undefined","has","delete","forEach","oldCache"],"mappings":"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","sourcesContent":["/* eslint consistent-this: 0, no-shadow:0, no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */\n\n// Support for asynchronous functions\n\n\"use strict\";\n\nvar aFrom        = require(\"es5-ext/array/from\")\n  , objectMap    = require(\"es5-ext/object/map\")\n  , mixin        = require(\"es5-ext/object/mixin\")\n  , defineLength = require(\"es5-ext/function/_define-length\")\n  , nextTick     = require(\"next-tick\");\n\nvar slice = Array.prototype.slice, apply = Function.prototype.apply, create = Object.create;\n\nrequire(\"../lib/registered-extensions\").async = function (tbi, conf) {\n\tvar waiting = create(null)\n\t  , cache = create(null)\n\t  , base = conf.memoized\n\t  , original = conf.original\n\t  , currentCallback\n\t  , currentContext\n\t  , currentArgs;\n\n\t// Initial\n\tconf.memoized = defineLength(function (arg) {\n\t\tvar args = arguments, last = args[args.length - 1];\n\t\tif (typeof last === \"function\") {\n\t\t\tcurrentCallback = last;\n\t\t\targs = slice.call(args, 0, -1);\n\t\t}\n\t\treturn base.apply(currentContext = this, currentArgs = args);\n\t}, base);\n\ttry { mixin(conf.memoized, base); }\n\tcatch (ignore) {}\n\n\t// From cache (sync)\n\tconf.on(\"get\", function (id) {\n\t\tvar cb, context, args;\n\t\tif (!currentCallback) return;\n\n\t\t// Unresolved\n\t\tif (waiting[id]) {\n\t\t\tif (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback];\n\t\t\telse waiting[id].push(currentCallback);\n\t\t\tcurrentCallback = null;\n\t\t\treturn;\n\t\t}\n\n\t\t// Resolved, assure next tick invocation\n\t\tcb = currentCallback;\n\t\tcontext = currentContext;\n\t\targs = currentArgs;\n\t\tcurrentCallback = currentContext = currentArgs = null;\n\t\tnextTick(function () {\n\t\t\tvar data;\n\t\t\tif (hasOwnProperty.call(cache, id)) {\n\t\t\t\tdata = cache[id];\n\t\t\t\tconf.emit(\"getasync\", id, args, context);\n\t\t\t\tapply.call(cb, data.context, data.args);\n\t\t\t} else {\n\t\t\t\t// Purged in a meantime, we shouldn't rely on cached value, recall\n\t\t\t\tcurrentCallback = cb;\n\t\t\t\tcurrentContext = context;\n\t\t\t\tcurrentArgs = args;\n\t\t\t\tbase.apply(context, args);\n\t\t\t}\n\t\t});\n\t});\n\n\t// Not from cache\n\tconf.original = function () {\n\t\tvar args, cb, origCb, result;\n\t\tif (!currentCallback) return apply.call(original, this, arguments);\n\t\targs = aFrom(arguments);\n\t\tcb = function self(err) {\n\t\t\tvar cb, args, id = self.id;\n\t\t\tif (id == null) {\n\t\t\t\t// Shouldn't happen, means async callback was called sync way\n\t\t\t\tnextTick(apply.bind(self, this, arguments));\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tdelete self.id;\n\t\t\tcb = waiting[id];\n\t\t\tdelete waiting[id];\n\t\t\tif (!cb) {\n\t\t\t\t// Already processed,\n\t\t\t\t// outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\targs = aFrom(arguments);\n\t\t\tif (conf.has(id)) {\n\t\t\t\tif (err) {\n\t\t\t\t\tconf.delete(id);\n\t\t\t\t} else {\n\t\t\t\t\tcache[id] = { context: this, args: args };\n\t\t\t\t\tconf.emit(\"setasync\", id, typeof cb === \"function\" ? 1 : cb.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof cb === \"function\") {\n\t\t\t\tresult = apply.call(cb, this, args);\n\t\t\t} else {\n\t\t\t\tcb.forEach(function (cb) { result = apply.call(cb, this, args); }, this);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\torigCb = currentCallback;\n\t\tcurrentCallback = currentContext = currentArgs = null;\n\t\targs.push(cb);\n\t\tresult = apply.call(original, this, args);\n\t\tcb.cb = origCb;\n\t\tcurrentCallback = cb;\n\t\treturn result;\n\t};\n\n\t// After not from cache call\n\tconf.on(\"set\", function (id) {\n\t\tif (!currentCallback) {\n\t\t\tconf.delete(id);\n\t\t\treturn;\n\t\t}\n\t\tif (waiting[id]) {\n\t\t\t// Race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n\t\t\tif (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback.cb];\n\t\t\telse waiting[id].push(currentCallback.cb);\n\t\t} else {\n\t\t\twaiting[id] = currentCallback.cb;\n\t\t}\n\t\tdelete currentCallback.cb;\n\t\tcurrentCallback.id = id;\n\t\tcurrentCallback = null;\n\t});\n\n\t// On delete\n\tconf.on(\"delete\", function (id) {\n\t\tvar result;\n\t\t// If false, we don't have value yet, so we assume that intention is not\n\t\t// to memoize this call. After value is obtained we don't cache it but\n\t\t// gracefully pass to callback\n\t\tif (hasOwnProperty.call(waiting, id)) return;\n\t\tif (!cache[id]) return;\n\t\tresult = cache[id];\n\t\tdelete cache[id];\n\t\tconf.emit(\"deleteasync\", id, slice.call(result.args, 1));\n\t});\n\n\t// On clear\n\tconf.on(\"clear\", function () {\n\t\tvar oldCache = cache;\n\t\tcache = create(null);\n\t\tconf.emit(\n\t\t\t\"clearasync\", objectMap(oldCache, function (data) { return slice.call(data.args, 1); })\n\t\t);\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}