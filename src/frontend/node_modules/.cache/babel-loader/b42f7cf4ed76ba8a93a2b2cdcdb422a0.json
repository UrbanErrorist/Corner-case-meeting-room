{"ast":null,"code":"'use strict';\n/**\n * Local dependencies\n */\n\nvar Ruler = require('./ruler');\n\nvar StateInline = require('./rules_inline/state_inline');\n\nvar utils = require('./common/utils');\n/**\n * Inline Parser `rules`\n */\n\n\nvar _rules = [['text', require('./rules_inline/text')], ['newline', require('./rules_inline/newline')], ['escape', require('./rules_inline/escape')], ['backticks', require('./rules_inline/backticks')], ['del', require('./rules_inline/del')], ['ins', require('./rules_inline/ins')], ['mark', require('./rules_inline/mark')], ['emphasis', require('./rules_inline/emphasis')], ['sub', require('./rules_inline/sub')], ['sup', require('./rules_inline/sup')], ['links', require('./rules_inline/links')], ['footnote_inline', require('./rules_inline/footnote_inline')], ['footnote_ref', require('./rules_inline/footnote_ref')], ['autolink', require('./rules_inline/autolink')], ['htmltag', require('./rules_inline/htmltag')], ['entity', require('./rules_inline/entity')]];\n/**\n * Inline Parser class. Note that link validation is stricter\n * in Remarkable than what is specified by CommonMark. If you\n * want to change this you can use a custom validator.\n *\n * @api private\n */\n\nfunction ParserInline() {\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  } // Can be overridden with a custom validator\n\n\n  this.validateLink = validateLink;\n}\n/**\n * Skip a single token by running all rules in validation mode.\n * Returns `true` if any rule reports success.\n *\n * @param  {Object} `state`\n * @api privage\n */\n\n\nParserInline.prototype.skipToken = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var pos = state.pos;\n  var i, cached_pos;\n\n  if ((cached_pos = state.cacheGet(pos)) > 0) {\n    state.pos = cached_pos;\n    return;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (rules[i](state, true)) {\n      state.cacheSet(pos, state.pos);\n      return;\n    }\n  }\n\n  state.pos++;\n  state.cacheSet(pos, state.pos);\n};\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state`\n * @api private\n */\n\n\nParserInline.prototype.tokenize = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var end = state.posMax;\n  var ok, i;\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, the rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, false);\n\n      if (ok) {\n        break;\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) {\n        break;\n      }\n\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n/**\n * Parse the given input string.\n *\n * @param  {String} `str`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\n\nParserInline.prototype.parse = function (str, options, env, outTokens) {\n  var state = new StateInline(str, this, options, env, outTokens);\n  this.tokenize(state);\n};\n/**\n * Validate the given `url` by checking for bad protocols.\n *\n * @param  {String} `url`\n * @return {Boolean}\n */\n\n\nfunction validateLink(url) {\n  var BAD_PROTOCOLS = ['vbscript', 'javascript', 'file', 'data'];\n  var str = url.trim().toLowerCase(); // Care about digital entities \"javascript&#x3A;alert(1)\"\n\n  str = utils.replaceEntities(str);\n\n  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Expose `ParserInline`\n */\n\n\nmodule.exports = ParserInline;","map":{"version":3,"sources":["/Users/blackhat/Desktop/testingRoom/src/frontend/node_modules/remarkable/lib/parser_inline.js"],"names":["Ruler","require","StateInline","utils","_rules","ParserInline","ruler","i","length","push","validateLink","prototype","skipToken","state","rules","getRules","len","pos","cached_pos","cacheGet","cacheSet","tokenize","end","posMax","ok","pending","src","pushPending","parse","str","options","env","outTokens","url","BAD_PROTOCOLS","trim","toLowerCase","replaceEntities","indexOf","split","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Local dependencies\n */\n\nvar Ruler       = require('./ruler');\nvar StateInline = require('./rules_inline/state_inline');\nvar utils       = require('./common/utils');\n\n/**\n * Inline Parser `rules`\n */\n\nvar _rules = [\n  [ 'text',            require('./rules_inline/text') ],\n  [ 'newline',         require('./rules_inline/newline') ],\n  [ 'escape',          require('./rules_inline/escape') ],\n  [ 'backticks',       require('./rules_inline/backticks') ],\n  [ 'del',             require('./rules_inline/del') ],\n  [ 'ins',             require('./rules_inline/ins') ],\n  [ 'mark',            require('./rules_inline/mark') ],\n  [ 'emphasis',        require('./rules_inline/emphasis') ],\n  [ 'sub',             require('./rules_inline/sub') ],\n  [ 'sup',             require('./rules_inline/sup') ],\n  [ 'links',           require('./rules_inline/links') ],\n  [ 'footnote_inline', require('./rules_inline/footnote_inline') ],\n  [ 'footnote_ref',    require('./rules_inline/footnote_ref') ],\n  [ 'autolink',        require('./rules_inline/autolink') ],\n  [ 'htmltag',         require('./rules_inline/htmltag') ],\n  [ 'entity',          require('./rules_inline/entity') ]\n];\n\n/**\n * Inline Parser class. Note that link validation is stricter\n * in Remarkable than what is specified by CommonMark. If you\n * want to change this you can use a custom validator.\n *\n * @api private\n */\n\nfunction ParserInline() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n\n  // Can be overridden with a custom validator\n  this.validateLink = validateLink;\n}\n\n/**\n * Skip a single token by running all rules in validation mode.\n * Returns `true` if any rule reports success.\n *\n * @param  {Object} `state`\n * @api privage\n */\n\nParserInline.prototype.skipToken = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var pos = state.pos;\n  var i, cached_pos;\n\n  if ((cached_pos = state.cacheGet(pos)) > 0) {\n    state.pos = cached_pos;\n    return;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (rules[i](state, true)) {\n      state.cacheSet(pos, state.pos);\n      return;\n    }\n  }\n\n  state.pos++;\n  state.cacheSet(pos, state.pos);\n};\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state`\n * @api private\n */\n\nParserInline.prototype.tokenize = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var end = state.posMax;\n  var ok, i;\n\n  while (state.pos < end) {\n\n    // Try all possible rules.\n    // On success, the rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, false);\n\n      if (ok) {\n        break;\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break; }\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n/**\n * Parse the given input string.\n *\n * @param  {String} `str`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserInline.prototype.parse = function (str, options, env, outTokens) {\n  var state = new StateInline(str, this, options, env, outTokens);\n  this.tokenize(state);\n};\n\n/**\n * Validate the given `url` by checking for bad protocols.\n *\n * @param  {String} `url`\n * @return {Boolean}\n */\n\nfunction validateLink(url) {\n  var BAD_PROTOCOLS = [ 'vbscript', 'javascript', 'file', 'data' ];\n  var str = url.trim().toLowerCase();\n  // Care about digital entities \"javascript&#x3A;alert(1)\"\n  str = utils.replaceEntities(str);\n  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Expose `ParserInline`\n */\n\nmodule.exports = ParserInline;\n"]},"metadata":{},"sourceType":"script"}