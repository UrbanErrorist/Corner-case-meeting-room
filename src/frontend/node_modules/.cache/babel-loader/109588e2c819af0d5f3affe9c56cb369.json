{"ast":null,"code":"// Paragraph\n'use strict';\n\nmodule.exports = function paragraph(state, startLine\n/*, endLine*/\n) {\n  var endLine,\n      content,\n      terminate,\n      i,\n      l,\n      nextLine = startLine + 1,\n      terminatorRules;\n  endLine = state.lineMax; // jump line-by-line until empty one or EOF\n\n  if (nextLine < endLine && !state.isEmpty(nextLine)) {\n    terminatorRules = state.parser.ruler.getRules('paragraph');\n\n    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.tShift[nextLine] - state.blkIndent > 3) {\n        continue;\n      } // Some tags can terminate paragraph without empty line.\n\n\n      terminate = false;\n\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n\n      if (terminate) {\n        break;\n      }\n    }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine;\n\n  if (content.length) {\n    state.tokens.push({\n      type: 'paragraph_open',\n      tight: false,\n      lines: [startLine, state.line],\n      level: state.level\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: content,\n      level: state.level + 1,\n      lines: [startLine, state.line],\n      children: []\n    });\n    state.tokens.push({\n      type: 'paragraph_close',\n      tight: false,\n      level: state.level\n    });\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/Users/blackhat/Desktop/testingRoom/src/frontend/node_modules/remarkable/lib/rules_block/paragraph.js"],"names":["module","exports","paragraph","state","startLine","endLine","content","terminate","i","l","nextLine","terminatorRules","lineMax","isEmpty","parser","ruler","getRules","tShift","blkIndent","length","getLines","trim","line","tokens","push","type","tight","lines","level","children"],"mappings":"AAAA;AAEA;;AAGAA,MAAM,CAACC,OAAP,GAAiB,SAASC,SAAT,CAAmBC,KAAnB,EAA0BC;AAAS;AAAnC,EAAkD;AACjE,MAAIC,OAAJ;AAAA,MAAaC,OAAb;AAAA,MAAsBC,SAAtB;AAAA,MAAiCC,CAAjC;AAAA,MAAoCC,CAApC;AAAA,MACIC,QAAQ,GAAGN,SAAS,GAAG,CAD3B;AAAA,MAEIO,eAFJ;AAIAN,EAAAA,OAAO,GAAGF,KAAK,CAACS,OAAhB,CALiE,CAOjE;;AACA,MAAIF,QAAQ,GAAGL,OAAX,IAAsB,CAACF,KAAK,CAACU,OAAN,CAAcH,QAAd,CAA3B,EAAoD;AAClDC,IAAAA,eAAe,GAAGR,KAAK,CAACW,MAAN,CAAaC,KAAb,CAAmBC,QAAnB,CAA4B,WAA5B,CAAlB;;AAEA,WAAON,QAAQ,GAAGL,OAAX,IAAsB,CAACF,KAAK,CAACU,OAAN,CAAcH,QAAd,CAA9B,EAAuDA,QAAQ,EAA/D,EAAmE;AACjE;AACA;AACA,UAAIP,KAAK,CAACc,MAAN,CAAaP,QAAb,IAAyBP,KAAK,CAACe,SAA/B,GAA2C,CAA/C,EAAkD;AAAE;AAAW,OAHE,CAKjE;;;AACAX,MAAAA,SAAS,GAAG,KAAZ;;AACA,WAAKC,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGE,eAAe,CAACQ,MAAhC,EAAwCX,CAAC,GAAGC,CAA5C,EAA+CD,CAAC,EAAhD,EAAoD;AAClD,YAAIG,eAAe,CAACH,CAAD,CAAf,CAAmBL,KAAnB,EAA0BO,QAA1B,EAAoCL,OAApC,EAA6C,IAA7C,CAAJ,EAAwD;AACtDE,UAAAA,SAAS,GAAG,IAAZ;AACA;AACD;AACF;;AACD,UAAIA,SAAJ,EAAe;AAAE;AAAQ;AAC1B;AACF;;AAEDD,EAAAA,OAAO,GAAGH,KAAK,CAACiB,QAAN,CAAehB,SAAf,EAA0BM,QAA1B,EAAoCP,KAAK,CAACe,SAA1C,EAAqD,KAArD,EAA4DG,IAA5D,EAAV;AAEAlB,EAAAA,KAAK,CAACmB,IAAN,GAAaZ,QAAb;;AACA,MAAIJ,OAAO,CAACa,MAAZ,EAAoB;AAClBhB,IAAAA,KAAK,CAACoB,MAAN,CAAaC,IAAb,CAAkB;AAChBC,MAAAA,IAAI,EAAE,gBADU;AAEhBC,MAAAA,KAAK,EAAE,KAFS;AAGhBC,MAAAA,KAAK,EAAE,CAAEvB,SAAF,EAAaD,KAAK,CAACmB,IAAnB,CAHS;AAIhBM,MAAAA,KAAK,EAAEzB,KAAK,CAACyB;AAJG,KAAlB;AAMAzB,IAAAA,KAAK,CAACoB,MAAN,CAAaC,IAAb,CAAkB;AAChBC,MAAAA,IAAI,EAAE,QADU;AAEhBnB,MAAAA,OAAO,EAAEA,OAFO;AAGhBsB,MAAAA,KAAK,EAAEzB,KAAK,CAACyB,KAAN,GAAc,CAHL;AAIhBD,MAAAA,KAAK,EAAE,CAAEvB,SAAF,EAAaD,KAAK,CAACmB,IAAnB,CAJS;AAKhBO,MAAAA,QAAQ,EAAE;AALM,KAAlB;AAOA1B,IAAAA,KAAK,CAACoB,MAAN,CAAaC,IAAb,CAAkB;AAChBC,MAAAA,IAAI,EAAE,iBADU;AAEhBC,MAAAA,KAAK,EAAE,KAFS;AAGhBE,MAAAA,KAAK,EAAEzB,KAAK,CAACyB;AAHG,KAAlB;AAKD;;AAED,SAAO,IAAP;AACD,CArDD","sourcesContent":["// Paragraph\n\n'use strict';\n\n\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\n  var endLine, content, terminate, i, l,\n      nextLine = startLine + 1,\n      terminatorRules;\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  if (nextLine < endLine && !state.isEmpty(nextLine)) {\n    terminatorRules = state.parser.ruler.getRules('paragraph');\n\n    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }\n\n      // Some tags can terminate paragraph without empty line.\n      terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) { break; }\n    }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n  if (content.length) {\n    state.tokens.push({\n      type: 'paragraph_open',\n      tight: false,\n      lines: [ startLine, state.line ],\n      level: state.level\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: content,\n      level: state.level + 1,\n      lines: [ startLine, state.line ],\n      children: []\n    });\n    state.tokens.push({\n      type: 'paragraph_close',\n      tight: false,\n      level: state.level\n    });\n  }\n\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}