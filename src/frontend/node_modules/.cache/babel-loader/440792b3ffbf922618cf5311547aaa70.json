{"ast":null,"code":"// Process ^superscript^\n'use strict'; // same as UNESCAPE_MD_RE plus a space\n\nvar UNESCAPE_RE = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nmodule.exports = function sup(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x5E\n  /* ^ */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 2 >= max) {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x5E\n    /* ^ */\n    ) {\n        found = true;\n        break;\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos); // don't allow unescaped spaces/newlines inside\n\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sup',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n};","map":{"version":3,"sources":["/Users/blackhat/Desktop/testingRoom/src/frontend/node_modules/remarkable/lib/rules_inline/sup.js"],"names":["UNESCAPE_RE","module","exports","sup","state","silent","found","content","max","posMax","start","pos","src","charCodeAt","level","options","maxNesting","parser","skipToken","slice","match","push","type","replace"],"mappings":"AAAA;AAEA,a,CAEA;;AACA,IAAIA,WAAW,GAAG,6CAAlB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,GAAT,CAAaC,KAAb,EAAoBC,MAApB,EAA4B;AAC3C,MAAIC,KAAJ;AAAA,MACIC,OADJ;AAAA,MAEIC,GAAG,GAAGJ,KAAK,CAACK,MAFhB;AAAA,MAGIC,KAAK,GAAGN,KAAK,CAACO,GAHlB;;AAKA,MAAIP,KAAK,CAACQ,GAAN,CAAUC,UAAV,CAAqBH,KAArB,MAAgC;AAAI;AAAxC,IAAiD;AAAE,aAAO,KAAP;AAAe;;AAClE,MAAIL,MAAJ,EAAY;AAAE,WAAO,KAAP;AAAe,GAPc,CAOb;;;AAC9B,MAAIK,KAAK,GAAG,CAAR,IAAaF,GAAjB,EAAsB;AAAE,WAAO,KAAP;AAAe;;AACvC,MAAIJ,KAAK,CAACU,KAAN,IAAeV,KAAK,CAACW,OAAN,CAAcC,UAAjC,EAA6C;AAAE,WAAO,KAAP;AAAe;;AAE9DZ,EAAAA,KAAK,CAACO,GAAN,GAAYD,KAAK,GAAG,CAApB;;AAEA,SAAON,KAAK,CAACO,GAAN,GAAYH,GAAnB,EAAwB;AACtB,QAAIJ,KAAK,CAACQ,GAAN,CAAUC,UAAV,CAAqBT,KAAK,CAACO,GAA3B,MAAoC;AAAI;AAA5C,MAAqD;AACnDL,QAAAA,KAAK,GAAG,IAAR;AACA;AACD;;AAEDF,IAAAA,KAAK,CAACa,MAAN,CAAaC,SAAb,CAAuBd,KAAvB;AACD;;AAED,MAAI,CAACE,KAAD,IAAUI,KAAK,GAAG,CAAR,KAAcN,KAAK,CAACO,GAAlC,EAAuC;AACrCP,IAAAA,KAAK,CAACO,GAAN,GAAYD,KAAZ;AACA,WAAO,KAAP;AACD;;AAEDH,EAAAA,OAAO,GAAGH,KAAK,CAACQ,GAAN,CAAUO,KAAV,CAAgBT,KAAK,GAAG,CAAxB,EAA2BN,KAAK,CAACO,GAAjC,CAAV,CA3B2C,CA6B3C;;AACA,MAAIJ,OAAO,CAACa,KAAR,CAAc,oBAAd,CAAJ,EAAyC;AACvChB,IAAAA,KAAK,CAACO,GAAN,GAAYD,KAAZ;AACA,WAAO,KAAP;AACD,GAjC0C,CAmC3C;;;AACAN,EAAAA,KAAK,CAACK,MAAN,GAAeL,KAAK,CAACO,GAArB;AACAP,EAAAA,KAAK,CAACO,GAAN,GAAYD,KAAK,GAAG,CAApB;;AAEA,MAAI,CAACL,MAAL,EAAa;AACXD,IAAAA,KAAK,CAACiB,IAAN,CAAW;AACTC,MAAAA,IAAI,EAAE,KADG;AAETR,MAAAA,KAAK,EAAEV,KAAK,CAACU,KAFJ;AAGTP,MAAAA,OAAO,EAAEA,OAAO,CAACgB,OAAR,CAAgBvB,WAAhB,EAA6B,IAA7B;AAHA,KAAX;AAKD;;AAEDI,EAAAA,KAAK,CAACO,GAAN,GAAYP,KAAK,CAACK,MAAN,GAAe,CAA3B;AACAL,EAAAA,KAAK,CAACK,MAAN,GAAeD,GAAf;AACA,SAAO,IAAP;AACD,CAlDD","sourcesContent":["// Process ^superscript^\n\n'use strict';\n\n// same as UNESCAPE_MD_RE plus a space\nvar UNESCAPE_RE = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nmodule.exports = function sup(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 2 >= max) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x5E/* ^ */) {\n      found = true;\n      break;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos);\n\n  // don't allow unescaped spaces/newlines inside\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sup',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}