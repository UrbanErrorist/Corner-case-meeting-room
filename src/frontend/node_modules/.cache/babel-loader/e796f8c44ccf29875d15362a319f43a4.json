{"ast":null,"code":"'use strict';\n\nvar repeat = require('repeat-string');\n\nvar splitOnTags = function splitOnTags(str) {\n  return str.split(/(<\\/?[^>]+>)/g).filter(function (line) {\n    return line.trim() !== '';\n  });\n};\n\nvar isTag = function isTag(str) {\n  return /<[^>!]+>/.test(str);\n};\n\nvar isClosingTag = function isClosingTag(str) {\n  return /<\\/+[^>]+>/.test(str);\n};\n\nvar isSelfClosingTag = function isSelfClosingTag(str) {\n  return /<[^>]+\\/>/.test(str);\n};\n\nvar isOpeningTag = function isOpeningTag(str) {\n  return isTag(str) && !isClosingTag(str) && !isSelfClosingTag(str);\n};\n\nmodule.exports = function (xml) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var indentor = config.indentor,\n      textNodesOnSameLine = config.textNodesOnSameLine;\n  var depth = 0;\n  var indicesToRemove = [];\n  indentor = indentor || '    ';\n  var rawResult = lexer(xml).map(function (element, i, arr) {\n    var value = element.value,\n        type = element.type;\n\n    if (type === 'ClosingTag') {\n      depth--;\n    }\n\n    var indentation = repeat(indentor, depth);\n    var line = indentation + value;\n\n    if (type === 'OpeningTag') {\n      depth++;\n    }\n\n    if (textNodesOnSameLine) {\n      // Lookbehind for [OpeningTag][Text][ClosingTag]\n      var oneBefore = arr[i - 1];\n      var twoBefore = arr[i - 2];\n\n      if (type === \"ClosingTag\" && oneBefore.type === \"Text\" && twoBefore.type === \"OpeningTag\") {\n        // collapse into a single line\n        line = '' + indentation + twoBefore.value + oneBefore.value + value;\n        indicesToRemove.push(i - 2, i - 1);\n      }\n    }\n\n    return line;\n  });\n  indicesToRemove.forEach(function (idx) {\n    return rawResult[idx] = null;\n  });\n  return rawResult.filter(function (val) {\n    return !!val;\n  }).join('\\n');\n};\n\nfunction lexer(xmlStr) {\n  var values = splitOnTags(xmlStr);\n  return values.map(function (value) {\n    return {\n      value: value,\n      type: getType(value)\n    };\n  });\n} // Helpers\n\n\nfunction getType(str) {\n  if (isClosingTag(str)) {\n    return 'ClosingTag';\n  }\n\n  if (isOpeningTag(str)) {\n    return 'OpeningTag';\n  }\n\n  if (isSelfClosingTag(str)) {\n    return 'SelfClosingTag';\n  }\n\n  return 'Text';\n}","map":{"version":3,"sources":["/Users/blackhat/Desktop/testingRoom/src/frontend/node_modules/xml-but-prettier/dist/index.js"],"names":["repeat","require","splitOnTags","str","split","filter","line","trim","isTag","test","isClosingTag","isSelfClosingTag","isOpeningTag","module","exports","xml","config","arguments","length","undefined","indentor","textNodesOnSameLine","depth","indicesToRemove","rawResult","lexer","map","element","i","arr","value","type","indentation","oneBefore","twoBefore","push","forEach","idx","val","join","xmlStr","values","getType"],"mappings":"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","sourcesContent":["'use strict';\n\nvar repeat = require('repeat-string');\n\nvar splitOnTags = function splitOnTags(str) {\n  return str.split(/(<\\/?[^>]+>)/g).filter(function (line) {\n    return line.trim() !== '';\n  });\n};\nvar isTag = function isTag(str) {\n  return (/<[^>!]+>/.test(str)\n  );\n};\nvar isClosingTag = function isClosingTag(str) {\n  return (/<\\/+[^>]+>/.test(str)\n  );\n};\nvar isSelfClosingTag = function isSelfClosingTag(str) {\n  return (/<[^>]+\\/>/.test(str)\n  );\n};\nvar isOpeningTag = function isOpeningTag(str) {\n  return isTag(str) && !isClosingTag(str) && !isSelfClosingTag(str);\n};\n\nmodule.exports = function (xml) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var indentor = config.indentor,\n      textNodesOnSameLine = config.textNodesOnSameLine;\n\n  var depth = 0;\n  var indicesToRemove = [];\n  indentor = indentor || '    ';\n\n  var rawResult = lexer(xml).map(function (element, i, arr) {\n    var value = element.value,\n        type = element.type;\n\n    if (type === 'ClosingTag') {\n      depth--;\n    }\n\n    var indentation = repeat(indentor, depth);\n    var line = indentation + value;\n\n    if (type === 'OpeningTag') {\n      depth++;\n    }\n\n    if (textNodesOnSameLine) {\n      // Lookbehind for [OpeningTag][Text][ClosingTag]\n      var oneBefore = arr[i - 1];\n      var twoBefore = arr[i - 2];\n\n      if (type === \"ClosingTag\" && oneBefore.type === \"Text\" && twoBefore.type === \"OpeningTag\") {\n        // collapse into a single line\n        line = '' + indentation + twoBefore.value + oneBefore.value + value;\n        indicesToRemove.push(i - 2, i - 1);\n      }\n    }\n\n    return line;\n  });\n\n  indicesToRemove.forEach(function (idx) {\n    return rawResult[idx] = null;\n  });\n\n  return rawResult.filter(function (val) {\n    return !!val;\n  }).join('\\n');\n};\n\nfunction lexer(xmlStr) {\n  var values = splitOnTags(xmlStr);\n  return values.map(function (value) {\n    return {\n      value: value,\n      type: getType(value)\n    };\n  });\n}\n\n// Helpers\n\nfunction getType(str) {\n  if (isClosingTag(str)) {\n    return 'ClosingTag';\n  }\n\n  if (isOpeningTag(str)) {\n    return 'OpeningTag';\n  }\n\n  if (isSelfClosingTag(str)) {\n    return 'SelfClosingTag';\n  }\n\n  return 'Text';\n}"]},"metadata":{},"sourceType":"script"}