{"ast":null,"code":"// Replace link-like texts with link nodes.\n//\n// Currently restricted by `inline.validateLink()` to http/https/ftp\n//\n'use strict';\n\nvar Autolinker = require('autolinker');\n\nvar LINK_SCAN_RE = /www|@|\\:\\/\\//;\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\n\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n} // Stupid fabric to avoid singletons, for thread safety.\n// Required for engines like Nashorn.\n//\n\n\nfunction createLinkifier() {\n  var links = [];\n  var autolinker = new Autolinker({\n    stripPrefix: false,\n    url: true,\n    email: true,\n    twitter: false,\n    replaceFn: function (linker, match) {\n      // Only collect matched strings but don't change anything.\n      switch (match.getType()) {\n        /*eslint default-case:0*/\n        case 'url':\n          links.push({\n            text: match.matchedText,\n            url: match.getUrl()\n          });\n          break;\n\n        case 'email':\n          links.push({\n            text: match.matchedText,\n            // normalize email protocol\n            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')\n          });\n          break;\n      }\n\n      return false;\n    }\n  });\n  return {\n    links: links,\n    autolinker: autolinker\n  };\n}\n\nmodule.exports = function linkify(state) {\n  var i,\n      j,\n      l,\n      tokens,\n      token,\n      text,\n      nodes,\n      ln,\n      pos,\n      level,\n      htmlLinkLevel,\n      blockTokens = state.tokens,\n      linkifier = null,\n      links,\n      autolinker;\n\n  if (!state.options.linkify) {\n    return;\n  }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') {\n      continue;\n    }\n\n    tokens = blockTokens[j].children;\n    htmlLinkLevel = 0; // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]; // Skip content of markdown links\n\n      if (token.type === 'link_close') {\n        i--;\n\n        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n\n        continue;\n      } // Skip content of html tag links\n\n\n      if (token.type === 'htmltag') {\n        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n\n        if (isLinkClose(token.content)) {\n          htmlLinkLevel++;\n        }\n      }\n\n      if (htmlLinkLevel > 0) {\n        continue;\n      }\n\n      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {\n        // Init linkifier in lazy manner, only if required.\n        if (!linkifier) {\n          linkifier = createLinkifier();\n          links = linkifier.links;\n          autolinker = linkifier.autolinker;\n        }\n\n        text = token.content;\n        links.length = 0;\n        autolinker.link(text);\n\n        if (!links.length) {\n          continue;\n        } // Now split string to nodes\n\n\n        nodes = [];\n        level = token.level;\n\n        for (ln = 0; ln < links.length; ln++) {\n          if (!state.inline.validateLink(links[ln].url)) {\n            continue;\n          }\n\n          pos = text.indexOf(links[ln].text);\n\n          if (pos) {\n            level = level;\n            nodes.push({\n              type: 'text',\n              content: text.slice(0, pos),\n              level: level\n            });\n          }\n\n          nodes.push({\n            type: 'link_open',\n            href: links[ln].url,\n            title: '',\n            level: level++\n          });\n          nodes.push({\n            type: 'text',\n            content: links[ln].text,\n            level: level\n          });\n          nodes.push({\n            type: 'link_close',\n            level: --level\n          });\n          text = text.slice(pos + links[ln].text.length);\n        }\n\n        if (text.length) {\n          nodes.push({\n            type: 'text',\n            content: text,\n            level: level\n          });\n        } // replace current node\n\n\n        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/remarkable/lib/rules_core/linkify.js"],"names":["Autolinker","require","LINK_SCAN_RE","isLinkOpen","str","test","isLinkClose","createLinkifier","links","autolinker","stripPrefix","url","email","twitter","replaceFn","linker","match","getType","push","text","matchedText","getUrl","getEmail","replace","module","exports","linkify","state","i","j","l","tokens","token","nodes","ln","pos","level","htmlLinkLevel","blockTokens","linkifier","options","length","type","children","content","link","inline","validateLink","indexOf","slice","href","title","concat"],"mappings":"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","sourcesContent":["// Replace link-like texts with link nodes.\n//\n// Currently restricted by `inline.validateLink()` to http/https/ftp\n//\n'use strict';\n\n\nvar Autolinker = require('autolinker');\n\n\nvar LINK_SCAN_RE = /www|@|\\:\\/\\//;\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n// Stupid fabric to avoid singletons, for thread safety.\n// Required for engines like Nashorn.\n//\nfunction createLinkifier() {\n  var links = [];\n  var autolinker = new Autolinker({\n    stripPrefix: false,\n    url: true,\n    email: true,\n    twitter: false,\n    replaceFn: function (linker, match) {\n      // Only collect matched strings but don't change anything.\n      switch (match.getType()) {\n        /*eslint default-case:0*/\n        case 'url':\n          links.push({\n            text: match.matchedText,\n            url: match.getUrl()\n          });\n          break;\n        case 'email':\n          links.push({\n            text: match.matchedText,\n            // normalize email protocol\n            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')\n          });\n          break;\n      }\n      return false;\n    }\n  });\n\n  return {\n    links: links,\n    autolinker: autolinker\n  };\n}\n\n\nmodule.exports = function linkify(state) {\n  var i, j, l, tokens, token, text, nodes, ln, pos, level, htmlLinkLevel,\n      blockTokens = state.tokens,\n      linkifier = null, links, autolinker;\n\n  if (!state.options.linkify) { return; }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') { continue; }\n    tokens = blockTokens[j].children;\n\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n\n      // Skip content of markdown links\n      if (token.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (token.type === 'htmltag') {\n        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(token.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) { continue; }\n\n      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {\n\n        // Init linkifier in lazy manner, only if required.\n        if (!linkifier) {\n          linkifier = createLinkifier();\n          links = linkifier.links;\n          autolinker = linkifier.autolinker;\n        }\n\n        text = token.content;\n        links.length = 0;\n        autolinker.link(text);\n\n        if (!links.length) { continue; }\n\n        // Now split string to nodes\n        nodes = [];\n        level = token.level;\n\n        for (ln = 0; ln < links.length; ln++) {\n\n          if (!state.inline.validateLink(links[ln].url)) { continue; }\n\n          pos = text.indexOf(links[ln].text);\n\n          if (pos) {\n            level = level;\n            nodes.push({\n              type: 'text',\n              content: text.slice(0, pos),\n              level: level\n            });\n          }\n          nodes.push({\n            type: 'link_open',\n            href: links[ln].url,\n            title: '',\n            level: level++\n          });\n          nodes.push({\n            type: 'text',\n            content: links[ln].text,\n            level: level\n          });\n          nodes.push({\n            type: 'link_close',\n            level: --level\n          });\n          text = text.slice(pos + links[ln].text.length);\n        }\n        if (text.length) {\n          nodes.push({\n            type: 'text',\n            content: text,\n            level: level\n          });\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}