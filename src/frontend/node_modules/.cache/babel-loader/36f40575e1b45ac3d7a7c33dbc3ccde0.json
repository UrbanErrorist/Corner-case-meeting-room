{"ast":null,"code":"'use strict';\n/*\n * OBJECT ASSIGN DEEP\n * Allows deep cloning of plain objects that contain primitives, nested plain objects, or nested plain arrays.\n */\n\n/*\n * A unified way of returning a string that describes the type of the given variable.\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nfunction getTypeOf(input) {\n  if (input === null) {\n    return 'null';\n  } else if (typeof input === 'undefined') {\n    return 'undefined';\n  } else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object') {\n    return Array.isArray(input) ? 'array' : 'object';\n  }\n\n  return typeof input === 'undefined' ? 'undefined' : _typeof(input);\n}\n/*\n * Branching logic which calls the correct function to clone the given value base on its type.\n */\n\n\nfunction cloneValue(value) {\n  // The value is an object so lets clone it.\n  if (getTypeOf(value) === 'object') {\n    return quickCloneObject(value);\n  } // The value is an array so lets clone it.\n  else if (getTypeOf(value) === 'array') {\n      return quickCloneArray(value);\n    } // Any other value can just be copied.\n\n\n  return value;\n}\n/*\n * Enumerates the given array and returns a new array, with each of its values cloned (i.e. references broken).\n */\n\n\nfunction quickCloneArray(input) {\n  return input.map(cloneValue);\n}\n/*\n * Enumerates the properties of the given object (ignoring the prototype chain) and returns a new object, with each of\n * its values cloned (i.e. references broken).\n */\n\n\nfunction quickCloneObject(input) {\n  var output = {};\n\n  for (var key in input) {\n    if (!input.hasOwnProperty(key)) {\n      continue;\n    }\n\n    output[key] = cloneValue(input[key]);\n  }\n\n  return output;\n}\n/*\n * Does the actual deep merging.\n */\n\n\nfunction executeDeepMerge(target) {\n  var _objects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  var _options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var options = {\n    arrayBehaviour: _options.arrayBehaviour || 'replace' // Can be \"merge\" or \"replace\".\n\n  }; // Ensure we have actual objects for each.\n\n  var objects = _objects.map(function (object) {\n    return object || {};\n  });\n\n  var output = target || {}; // Enumerate the objects and their keys.\n\n  for (var oindex = 0; oindex < objects.length; oindex++) {\n    var object = objects[oindex];\n    var keys = Object.keys(object);\n\n    for (var kindex = 0; kindex < keys.length; kindex++) {\n      var key = keys[kindex];\n      var value = object[key];\n      var type = getTypeOf(value);\n      var existingValueType = getTypeOf(output[key]);\n\n      if (type === 'object') {\n        if (existingValueType !== 'undefined') {\n          var existingValue = existingValueType === 'object' ? output[key] : {};\n          output[key] = executeDeepMerge({}, [existingValue, quickCloneObject(value)], options);\n        } else {\n          output[key] = quickCloneObject(value);\n        }\n      } else if (type === 'array') {\n        if (existingValueType === 'array') {\n          var newValue = quickCloneArray(value);\n          output[key] = options.arrayBehaviour === 'merge' ? output[key].concat(newValue) : newValue;\n        } else {\n          output[key] = quickCloneArray(value);\n        }\n      } else {\n        output[key] = value;\n      }\n    }\n  }\n\n  return output;\n}\n/*\n * Merge all the supplied objects into the target object, breaking all references, including those of nested objects\n * and arrays, and even objects nested inside arrays. The first parameter is not mutated unlike Object.assign().\n * Properties in later objects will always overwrite.\n */\n\n\nmodule.exports = function objectAssignDeep(target) {\n  for (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n\n  return executeDeepMerge(target, objects);\n};\n/*\n * Same as objectAssignDeep() except it doesn't mutate the target object and returns an entirely new object.\n */\n\n\nmodule.exports.noMutate = function objectAssignDeepInto() {\n  for (var _len2 = arguments.length, objects = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    objects[_key2] = arguments[_key2];\n  }\n\n  return executeDeepMerge({}, objects);\n};\n/*\n * Allows an options object to be passed in to customise the behaviour of the function.\n */\n\n\nmodule.exports.withOptions = function objectAssignDeepInto(target, objects, options) {\n  return executeDeepMerge(target, objects, options);\n};","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/@kyleshockey/object-assign-deep/dist/objectAssignDeep.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","getTypeOf","input","Array","isArray","cloneValue","value","quickCloneObject","quickCloneArray","map","output","key","hasOwnProperty","executeDeepMerge","target","_objects","arguments","length","undefined","_options","options","arrayBehaviour","objects","object","oindex","keys","Object","kindex","type","existingValueType","existingValue","newValue","concat","module","exports","objectAssignDeep","_len","_key","noMutate","objectAssignDeepInto","_len2","_key2","withOptions"],"mappings":"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","sourcesContent":["'use strict';\n\n/*\n * OBJECT ASSIGN DEEP\n * Allows deep cloning of plain objects that contain primitives, nested plain objects, or nested plain arrays.\n */\n\n/*\n * A unified way of returning a string that describes the type of the given variable.\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction getTypeOf(input) {\n\n\tif (input === null) {\n\t\treturn 'null';\n\t} else if (typeof input === 'undefined') {\n\t\treturn 'undefined';\n\t} else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object') {\n\t\treturn Array.isArray(input) ? 'array' : 'object';\n\t}\n\n\treturn typeof input === 'undefined' ? 'undefined' : _typeof(input);\n}\n\n/*\n * Branching logic which calls the correct function to clone the given value base on its type.\n */\nfunction cloneValue(value) {\n\n\t// The value is an object so lets clone it.\n\tif (getTypeOf(value) === 'object') {\n\t\treturn quickCloneObject(value);\n\t}\n\n\t// The value is an array so lets clone it.\n\telse if (getTypeOf(value) === 'array') {\n\t\t\treturn quickCloneArray(value);\n\t\t}\n\n\t// Any other value can just be copied.\n\treturn value;\n}\n\n/*\n * Enumerates the given array and returns a new array, with each of its values cloned (i.e. references broken).\n */\nfunction quickCloneArray(input) {\n\treturn input.map(cloneValue);\n}\n\n/*\n * Enumerates the properties of the given object (ignoring the prototype chain) and returns a new object, with each of\n * its values cloned (i.e. references broken).\n */\nfunction quickCloneObject(input) {\n\n\tvar output = {};\n\n\tfor (var key in input) {\n\t\tif (!input.hasOwnProperty(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\toutput[key] = cloneValue(input[key]);\n\t}\n\n\treturn output;\n}\n\n/*\n * Does the actual deep merging.\n */\nfunction executeDeepMerge(target) {\n\tvar _objects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n\tvar _options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\tvar options = {\n\t\tarrayBehaviour: _options.arrayBehaviour || 'replace' // Can be \"merge\" or \"replace\".\n\t};\n\n\t// Ensure we have actual objects for each.\n\tvar objects = _objects.map(function (object) {\n\t\treturn object || {};\n\t});\n\tvar output = target || {};\n\n\t// Enumerate the objects and their keys.\n\tfor (var oindex = 0; oindex < objects.length; oindex++) {\n\t\tvar object = objects[oindex];\n\t\tvar keys = Object.keys(object);\n\n\t\tfor (var kindex = 0; kindex < keys.length; kindex++) {\n\t\t\tvar key = keys[kindex];\n\t\t\tvar value = object[key];\n\t\t\tvar type = getTypeOf(value);\n\t\t\tvar existingValueType = getTypeOf(output[key]);\n\n\t\t\tif (type === 'object') {\n\t\t\t\tif (existingValueType !== 'undefined') {\n\t\t\t\t\tvar existingValue = existingValueType === 'object' ? output[key] : {};\n\t\t\t\t\toutput[key] = executeDeepMerge({}, [existingValue, quickCloneObject(value)], options);\n\t\t\t\t} else {\n\t\t\t\t\toutput[key] = quickCloneObject(value);\n\t\t\t\t}\n\t\t\t} else if (type === 'array') {\n\t\t\t\tif (existingValueType === 'array') {\n\t\t\t\t\tvar newValue = quickCloneArray(value);\n\t\t\t\t\toutput[key] = options.arrayBehaviour === 'merge' ? output[key].concat(newValue) : newValue;\n\t\t\t\t} else {\n\t\t\t\t\toutput[key] = quickCloneArray(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output;\n}\n\n/*\n * Merge all the supplied objects into the target object, breaking all references, including those of nested objects\n * and arrays, and even objects nested inside arrays. The first parameter is not mutated unlike Object.assign().\n * Properties in later objects will always overwrite.\n */\nmodule.exports = function objectAssignDeep(target) {\n\tfor (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\tobjects[_key - 1] = arguments[_key];\n\t}\n\n\treturn executeDeepMerge(target, objects);\n};\n\n/*\n * Same as objectAssignDeep() except it doesn't mutate the target object and returns an entirely new object.\n */\nmodule.exports.noMutate = function objectAssignDeepInto() {\n\tfor (var _len2 = arguments.length, objects = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\tobjects[_key2] = arguments[_key2];\n\t}\n\n\treturn executeDeepMerge({}, objects);\n};\n\n/*\n * Allows an options object to be passed in to customise the behaviour of the function.\n */\nmodule.exports.withOptions = function objectAssignDeepInto(target, objects, options) {\n\treturn executeDeepMerge(target, objects, options);\n};"]},"metadata":{},"sourceType":"script"}