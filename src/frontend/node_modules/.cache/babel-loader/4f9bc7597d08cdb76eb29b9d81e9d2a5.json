{"ast":null,"code":"// Process ++inserted text++\n'use strict';\n\nmodule.exports = function ins(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 4 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start + 1) !== 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x20 || nextChar === 0x0A) {\n    return false;\n  }\n\n  pos = start + 2;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x2B\n  /* + */\n  ) {\n    pos++;\n  }\n\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n\n    if (!silent) {\n      state.pending += state.src.slice(start, pos);\n    }\n\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x2B\n    /* + */\n    ) {\n        if (state.src.charCodeAt(state.pos + 1) === 0x2B\n        /* + */\n        ) {\n            lastChar = state.src.charCodeAt(state.pos - 1);\n            nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n\n            if (nextChar !== 0x2B\n            /* + */\n            && lastChar !== 0x2B\n            /* + */\n            ) {\n                if (lastChar !== 0x20 && lastChar !== 0x0A) {\n                  // closing '++'\n                  stack--;\n                } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n                  // opening '++'\n                  stack++;\n                } // else {\n                //  // standalone ' ++ ' indented with spaces\n                // }\n\n\n                if (stack <= 0) {\n                  found = true;\n                  break;\n                }\n              }\n          }\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({\n      type: 'ins_open',\n      level: state.level++\n    });\n    state.parser.tokenize(state);\n    state.push({\n      type: 'ins_close',\n      level: --state.level\n    });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n};","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/remarkable/lib/rules_inline/ins.js"],"names":["module","exports","ins","state","silent","found","pos","stack","max","posMax","start","lastChar","nextChar","src","charCodeAt","level","options","maxNesting","pending","slice","parser","skipToken","push","type","tokenize"],"mappings":"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","sourcesContent":["// Process ++inserted text++\n\n'use strict';\n\nmodule.exports = function ins(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x2B/* + */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 4 >= max) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x2B/* + */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x2B/* + */) { return false; }\n  if (nextChar === 0x2B/* + */) { return false; }\n  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x2B/* + */) { pos++; }\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) { state.pending += state.src.slice(start, pos); }\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x2B/* + */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x2B/* + */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x2B/* + */ && lastChar !== 0x2B/* + */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '++'\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '++'\n            stack++;\n          } // else {\n            //  // standalone ' ++ ' indented with spaces\n            // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({ type: 'ins_open', level: state.level++ });\n    state.parser.tokenize(state);\n    state.push({ type: 'ins_close', level: --state.level });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}