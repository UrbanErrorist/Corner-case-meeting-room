{"ast":null,"code":"// Block quotes\n'use strict';\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var nextLine,\n      lastLineEmpty,\n      oldTShift,\n      oldBMarks,\n      oldIndent,\n      oldParentType,\n      lines,\n      terminatorRules,\n      i,\n      l,\n      terminate,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos > max) {\n    return false;\n  } // check the block quote marker\n\n\n  if (state.src.charCodeAt(pos++) !== 0x3E\n  /* > */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n\n\n  if (silent) {\n    return true;\n  } // skip one optional space after '>'\n\n\n  if (state.src.charCodeAt(pos) === 0x20) {\n    pos++;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n  oldBMarks = [state.bMarks[startLine]];\n  state.bMarks[startLine] = pos; // check if we have an empty blockquote\n\n  pos = pos < max ? state.skipSpaces(pos) : pos;\n  lastLineEmpty = pos >= max;\n  oldTShift = [state.tShift[startLine]];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n  terminatorRules = state.parser.ruler.getRules('blockquote'); // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E\n    /* > */\n    ) {\n        // This line is inside the blockquote.\n        // skip one optional space after '>'\n        if (state.src.charCodeAt(pos) === 0x20) {\n          pos++;\n        }\n\n        oldBMarks.push(state.bMarks[nextLine]);\n        state.bMarks[nextLine] = pos;\n        pos = pos < max ? state.skipSpaces(pos) : pos;\n        lastLineEmpty = pos >= max;\n        oldTShift.push(state.tShift[nextLine]);\n        state.tShift[nextLine] = pos - state.bMarks[nextLine];\n        continue;\n      } // Case 2: line is not inside the blockquote, and the last line was empty.\n\n\n    if (lastLineEmpty) {\n      break;\n    } // Case 3: another tag found.\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]); // A negative number means that this is a paragraph continuation;\n    //\n    // Any negative number will do the job here, but it's better for it\n    // to be large enough to make any bugs obvious.\n\n    state.tShift[nextLine] = -1337;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  state.tokens.push({\n    type: 'blockquote_open',\n    lines: lines = [startLine, 0],\n    level: state.level++\n  });\n  state.parser.tokenize(state, startLine, nextLine);\n  state.tokens.push({\n    type: 'blockquote_close',\n    level: --state.level\n  });\n  state.parentType = oldParentType;\n  lines[1] = state.line; // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n  }\n\n  state.blkIndent = oldIndent;\n  return true;\n};","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/remarkable/lib/rules_block/blockquote.js"],"names":["module","exports","blockquote","state","startLine","endLine","silent","nextLine","lastLineEmpty","oldTShift","oldBMarks","oldIndent","oldParentType","lines","terminatorRules","i","l","terminate","pos","bMarks","tShift","max","eMarks","src","charCodeAt","level","options","maxNesting","blkIndent","skipSpaces","parser","ruler","getRules","push","length","parentType","tokens","type","tokenize","line"],"mappings":"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","sourcesContent":["// Block quotes\n\n'use strict';\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,\n      terminatorRules,\n      i, l, terminate,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos > max) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  // check if we have an empty blockquote\n  pos = pos < max ? state.skipSpaces(pos) : pos;\n  lastLineEmpty = pos >= max;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.parser.ruler.getRules('blockquote');\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {\n      // This line is inside the blockquote.\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      pos = pos < max ? state.skipSpaces(pos) : pos;\n      lastLineEmpty = pos >= max;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n\n    // A negative number means that this is a paragraph continuation;\n    //\n    // Any negative number will do the job here, but it's better for it\n    // to be large enough to make any bugs obvious.\n    state.tShift[nextLine] = -1337;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  state.tokens.push({\n    type: 'blockquote_open',\n    lines: lines = [ startLine, 0 ],\n    level: state.level++\n  });\n  state.parser.tokenize(state, startLine, nextLine);\n  state.tokens.push({\n    type: 'blockquote_close',\n    level: --state.level\n  });\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}