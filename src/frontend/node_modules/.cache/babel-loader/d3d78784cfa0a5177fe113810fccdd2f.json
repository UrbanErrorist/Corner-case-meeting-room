{"ast":null,"code":"// Process *this* and _that_\n'use strict';\n\nfunction isAlphaNum(code) {\n  return code >= 0x30\n  /* 0 */\n  && code <= 0x39\n  /* 9 */\n  || code >= 0x41\n  /* A */\n  && code <= 0x5A\n  /* Z */\n  || code >= 0x61\n  /* a */\n  && code <= 0x7A\n  /* z */\n  ;\n} // parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\n\n\nfunction scanDelims(state, start) {\n  var pos = start,\n      lastChar,\n      nextChar,\n      count,\n      can_open = true,\n      can_close = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n\n  if (pos >= max) {\n    can_open = false;\n  }\n\n  count = pos - start;\n\n  if (count >= 4) {\n    // sequence of four or more unescaped markers can't start/end an emphasis\n    can_open = can_close = false;\n  } else {\n    nextChar = pos < max ? state.src.charCodeAt(pos) : -1; // check whitespace conditions\n\n    if (nextChar === 0x20 || nextChar === 0x0A) {\n      can_open = false;\n    }\n\n    if (lastChar === 0x20 || lastChar === 0x0A) {\n      can_close = false;\n    }\n\n    if (marker === 0x5F\n    /* _ */\n    ) {\n        // check if we aren't inside the word\n        if (isAlphaNum(lastChar)) {\n          can_open = false;\n        }\n\n        if (isAlphaNum(nextChar)) {\n          can_close = false;\n        }\n      }\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\nmodule.exports = function emphasis(state, silent) {\n  var startCount,\n      count,\n      found,\n      oldCount,\n      newCount,\n      stack,\n      res,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x5F\n  /* _ */\n  && marker !== 0x2A\n  /* * */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n\n  if (!res.can_open) {\n    state.pos += startCount;\n\n    if (!silent) {\n      state.pending += state.src.slice(start, state.pos);\n    }\n\n    return true;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  state.pos = start + startCount;\n  stack = [startCount];\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          } // assert(newCount > oldCount)\n\n\n          newCount -= oldCount;\n\n          if (stack.length === 0) {\n            break;\n          }\n\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) {\n        stack.push(count);\n      }\n\n      state.pos += count;\n      continue;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  if (!silent) {\n    if (startCount === 2 || startCount === 3) {\n      state.push({\n        type: 'strong_open',\n        level: state.level++\n      });\n    }\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({\n        type: 'em_open',\n        level: state.level++\n      });\n    }\n\n    state.parser.tokenize(state);\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({\n        type: 'em_close',\n        level: --state.level\n      });\n    }\n\n    if (startCount === 2 || startCount === 3) {\n      state.push({\n        type: 'strong_close',\n        level: --state.level\n      });\n    }\n  }\n\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n};","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/remarkable/lib/rules_inline/emphasis.js"],"names":["isAlphaNum","code","scanDelims","state","start","pos","lastChar","nextChar","count","can_open","can_close","max","posMax","marker","src","charCodeAt","delims","module","exports","emphasis","silent","startCount","found","oldCount","newCount","stack","res","pending","slice","level","options","maxNesting","pop","push","length","parser","skipToken","type","tokenize"],"mappings":"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","sourcesContent":["// Process *this* and _that_\n\n'use strict';\n\n\nfunction isAlphaNum(code) {\n  return (code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */) ||\n         (code >= 0x41 /* A */ && code <= 0x5A /* Z */) ||\n         (code >= 0x61 /* a */ && code <= 0x7A /* z */);\n}\n\n// parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\nfunction scanDelims(state, start) {\n  var pos = start, lastChar, nextChar, count,\n      can_open = true,\n      can_close = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }\n  if (pos >= max) { can_open = false; }\n  count = pos - start;\n\n  if (count >= 4) {\n    // sequence of four or more unescaped markers can't start/end an emphasis\n    can_open = can_close = false;\n  } else {\n    nextChar = pos < max ? state.src.charCodeAt(pos) : -1;\n\n    // check whitespace conditions\n    if (nextChar === 0x20 || nextChar === 0x0A) { can_open = false; }\n    if (lastChar === 0x20 || lastChar === 0x0A) { can_close = false; }\n\n    if (marker === 0x5F /* _ */) {\n      // check if we aren't inside the word\n      if (isAlphaNum(lastChar)) { can_open = false; }\n      if (isAlphaNum(nextChar)) { can_close = false; }\n    }\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\nmodule.exports = function emphasis(state, silent) {\n  var startCount,\n      count,\n      found,\n      oldCount,\n      newCount,\n      stack,\n      res,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n  if (!res.can_open) {\n    state.pos += startCount;\n    if (!silent) { state.pending += state.src.slice(start, state.pos); }\n    return true;\n  }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + startCount;\n  stack = [ startCount ];\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          }\n\n          // assert(newCount > oldCount)\n          newCount -= oldCount;\n\n          if (stack.length === 0) { break; }\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) { stack.push(count); }\n      state.pos += count;\n      continue;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  if (!silent) {\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_open', level: state.level++ });\n    }\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_open', level: state.level++ });\n    }\n\n    state.parser.tokenize(state);\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_close', level: --state.level });\n    }\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_close', level: --state.level });\n    }\n  }\n\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}