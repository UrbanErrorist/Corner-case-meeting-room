{"ast":null,"code":"// Parser state class\n'use strict';\n\nfunction StateBlock(src, parser, options, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n  this.src = src; // Shortcuts to simplify nested calls\n\n  this.parser = parser;\n  this.options = options;\n  this.env = env; //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n  this.bMarks = []; // line begin offsets for fast jumps\n\n  this.eMarks = []; // line end offsets for fast jumps\n\n  this.tShift = []; // indent for each line\n  // block parser variables\n\n  this.blkIndent = 0; // required block content indent\n  // (for example, if we are in list)\n\n  this.line = 0; // line index in src\n\n  this.lineMax = 0; // lines count\n\n  this.tight = false; // loose/tight mode for lists\n\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n\n  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0; // renderer\n\n  this.result = ''; // Create caches\n  // Generate markers.\n\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (ch === 0x20\n      /* space */\n      ) {\n          indent++;\n          continue;\n        } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) {\n        pos++;\n      }\n\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  } // Push fake entry to simplify cache bounds checks\n\n\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n\n  return from;\n}; // Skip spaces from given position.\n\n\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20\n    /* space */\n    ) {\n        break;\n      }\n  }\n\n  return pos;\n}; // Skip char codes from given position\n\n\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) {\n      break;\n    }\n  }\n\n  return pos;\n}; // Skip char codes reverse from given position - 1\n\n\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) {\n    return pos;\n  }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) {\n      return pos + 1;\n    }\n  }\n\n  return pos;\n}; // cut lines range from source.\n\n\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i,\n      first,\n      last,\n      queue,\n      shift,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  } // Opt: don't use push queue for single line;\n\n\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\n    return this.src.slice(first, last);\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n\n    if (shift > indent) {\n      shift = indent;\n    }\n\n    if (shift < 0) {\n      shift = 0;\n    }\n\n    first = this.bMarks[line] + shift;\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    queue[i] = this.src.slice(first, last);\n  }\n\n  return queue.join('');\n};\n\nmodule.exports = StateBlock;","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/remarkable/lib/rules_block/state_block.js"],"names":["StateBlock","src","parser","options","env","tokens","ch","s","start","pos","len","indent","indent_found","bMarks","eMarks","tShift","blkIndent","line","lineMax","tight","parentType","ddIndent","level","result","length","charCodeAt","push","prototype","isEmpty","skipEmptyLines","from","max","skipSpaces","skipChars","code","skipCharsBack","min","getLines","begin","end","keepLastLF","i","first","last","queue","shift","Math","slice","Array","join","module","exports"],"mappings":"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","sourcesContent":["// Parser state class\n\n'use strict';\n\n\nfunction StateBlock(src, parser, options, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n\n  this.src = src;\n\n  // Shortcuts to simplify nested calls\n  this.parser = parser;\n\n  this.options = options;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // indent for each line\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent\n                       // (for example, if we are in list)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (ch === 0x20/* space */) {\n        indent++;\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, first, last, queue, shift,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  // Opt: don't use push queue for single line;\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\n    return this.src.slice(first, last);\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n    if (shift > indent) { shift = indent; }\n    if (shift < 0) { shift = 0; }\n\n    first = this.bMarks[line] + shift;\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    queue[i] = this.src.slice(first, last);\n  }\n\n  return queue.join('');\n};\n\n\nmodule.exports = StateBlock;\n"]},"metadata":{},"sourceType":"script"}