{"ast":null,"code":"// HTML block\n'use strict';\n\nvar block_names = require('../common/html_blocks');\n\nvar HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\\s\\/>]/;\nvar HTML_TAG_CLOSE_RE = /^<\\/([a-zA-Z]{1,15})[\\s>]/;\n\nfunction isLetter(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n\n  return lc >= 0x61\n  /* a */\n  && lc <= 0x7a\n  /* z */\n  ;\n}\n\nmodule.exports = function htmlblock(state, startLine, endLine, silent) {\n  var ch,\n      match,\n      nextLine,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine],\n      shift = state.tShift[startLine];\n  pos += shift;\n\n  if (!state.options.html) {\n    return false;\n  }\n\n  if (shift > 3 || pos + 2 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(pos) !== 0x3C\n  /* < */\n  ) {\n      return false;\n    }\n\n  ch = state.src.charCodeAt(pos + 1);\n\n  if (ch === 0x21\n  /* ! */\n  || ch === 0x3F\n  /* ? */\n  ) {\n      // Directive start / comment start / processing instruction start\n      if (silent) {\n        return true;\n      }\n    } else if (ch === 0x2F\n  /* / */\n  || isLetter(ch)) {\n    // Probably start or end of tag\n    if (ch === 0x2F\n    /* \\ */\n    ) {\n        // closing tag\n        match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);\n\n        if (!match) {\n          return false;\n        }\n      } else {\n      // opening tag\n      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);\n\n      if (!match) {\n        return false;\n      }\n    } // Make sure tag name is valid\n\n\n    if (block_names[match[1].toLowerCase()] !== true) {\n      return false;\n    }\n\n    if (silent) {\n      return true;\n    }\n  } else {\n    return false;\n  } // If we are here - we detected HTML block.\n  // Let's roll down till empty line (block end).\n\n\n  nextLine = startLine + 1;\n\n  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {\n    nextLine++;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'htmlblock',\n    level: state.level,\n    lines: [startLine, state.line],\n    content: state.getLines(startLine, nextLine, 0, true)\n  });\n  return true;\n};","map":{"version":3,"sources":["/Users/blackhat/Desktop/testingRoom/src/frontend/node_modules/remarkable/lib/rules_block/htmlblock.js"],"names":["block_names","require","HTML_TAG_OPEN_RE","HTML_TAG_CLOSE_RE","isLetter","ch","lc","module","exports","htmlblock","state","startLine","endLine","silent","match","nextLine","pos","bMarks","max","eMarks","shift","tShift","options","html","src","charCodeAt","slice","toLowerCase","lineMax","isEmpty","line","tokens","push","type","level","lines","content","getLines"],"mappings":"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","sourcesContent":["// HTML block\n\n'use strict';\n\n\nvar block_names = require('../common/html_blocks');\n\n\nvar HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\\s\\/>]/;\nvar HTML_TAG_CLOSE_RE = /^<\\/([a-zA-Z]{1,15})[\\s>]/;\n\nfunction isLetter(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\nmodule.exports = function htmlblock(state, startLine, endLine, silent) {\n  var ch, match, nextLine,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine],\n      shift = state.tShift[startLine];\n\n  pos += shift;\n\n  if (!state.options.html) { return false; }\n\n  if (shift > 3 || pos + 2 >= max) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  ch = state.src.charCodeAt(pos + 1);\n\n  if (ch === 0x21/* ! */ || ch === 0x3F/* ? */) {\n    // Directive start / comment start / processing instruction start\n    if (silent) { return true; }\n\n  } else if (ch === 0x2F/* / */ || isLetter(ch)) {\n\n    // Probably start or end of tag\n    if (ch === 0x2F/* \\ */) {\n      // closing tag\n      match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);\n      if (!match) { return false; }\n    } else {\n      // opening tag\n      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);\n      if (!match) { return false; }\n    }\n    // Make sure tag name is valid\n    if (block_names[match[1].toLowerCase()] !== true) { return false; }\n    if (silent) { return true; }\n\n  } else {\n    return false;\n  }\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till empty line (block end).\n  nextLine = startLine + 1;\n  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {\n    nextLine++;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'htmlblock',\n    level: state.level,\n    lines: [ startLine, state.line ],\n    content: state.getLines(startLine, nextLine, 0, true)\n  });\n\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}