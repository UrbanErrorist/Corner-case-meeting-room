{"ast":null,"code":"// Inline parser state\n'use strict';\n\nfunction StateInline(src, parserInline, options, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.options = options;\n  this.parser = parserInline;\n  this.tokens = outTokens;\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n  this.cache = []; // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  // Link parser state vars\n\n  this.isInLabel = false; // Set true when seek link label - we should disable\n  // \"paired\" rules (emphasis, strikes) to not skip\n  // tailing `]`\n\n  this.linkLevel = 0; // Increment for each nesting link. Used to prevent\n  // nesting in definitions\n\n  this.linkContent = ''; // Temporary storage for link url\n\n  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels\n  // (backtrack optimization)\n} // Flush pending text\n//\n\n\nStateInline.prototype.pushPending = function () {\n  this.tokens.push({\n    type: 'text',\n    content: this.pending,\n    level: this.pendingLevel\n  });\n  this.pending = '';\n}; // Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\n\n\nStateInline.prototype.push = function (token) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  this.tokens.push(token);\n  this.pendingLevel = this.level;\n}; // Store value to cache.\n// !!! Implementation has parser-specific optimizations\n// !!! keys MUST be integer, >= 0; values MUST be integer, > 0\n//\n\n\nStateInline.prototype.cacheSet = function (key, val) {\n  for (var i = this.cache.length; i <= key; i++) {\n    this.cache.push(0);\n  }\n\n  this.cache[key] = val;\n}; // Get cache value\n//\n\n\nStateInline.prototype.cacheGet = function (key) {\n  return key < this.cache.length ? this.cache[key] : 0;\n};\n\nmodule.exports = StateInline;","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/remarkable/lib/rules_inline/state_inline.js"],"names":["StateInline","src","parserInline","options","env","outTokens","parser","tokens","pos","posMax","length","level","pending","pendingLevel","cache","isInLabel","linkLevel","linkContent","labelUnmatchedScopes","prototype","pushPending","push","type","content","token","cacheSet","key","val","i","cacheGet","module","exports"],"mappings":"AAAA;AAEA;;AAEA,SAASA,WAAT,CAAqBC,GAArB,EAA0BC,YAA1B,EAAwCC,OAAxC,EAAiDC,GAAjD,EAAsDC,SAAtD,EAAiE;AAC/D,OAAKJ,GAAL,GAAWA,GAAX;AACA,OAAKG,GAAL,GAAWA,GAAX;AACA,OAAKD,OAAL,GAAeA,OAAf;AACA,OAAKG,MAAL,GAAcJ,YAAd;AACA,OAAKK,MAAL,GAAcF,SAAd;AACA,OAAKG,GAAL,GAAW,CAAX;AACA,OAAKC,MAAL,GAAc,KAAKR,GAAL,CAASS,MAAvB;AACA,OAAKC,KAAL,GAAa,CAAb;AACA,OAAKC,OAAL,GAAe,EAAf;AACA,OAAKC,YAAL,GAAoB,CAApB;AAEA,OAAKC,KAAL,GAAa,EAAb,CAZ+D,CAYvC;AACA;AAExB;;AAEA,OAAKC,SAAL,GAAiB,KAAjB,CAjB+D,CAiBvC;AACA;AACA;;AAExB,OAAKC,SAAL,GAAiB,CAAjB,CArB+D,CAqBvC;AACA;;AAExB,OAAKC,WAAL,GAAmB,EAAnB,CAxB+D,CAwBvC;;AAExB,OAAKC,oBAAL,GAA4B,CAA5B,CA1B+D,CA0BhC;AACA;AAChC,C,CAED;AACA;;;AACAlB,WAAW,CAACmB,SAAZ,CAAsBC,WAAtB,GAAoC,YAAY;AAC9C,OAAKb,MAAL,CAAYc,IAAZ,CAAiB;AACfC,IAAAA,IAAI,EAAE,MADS;AAEfC,IAAAA,OAAO,EAAE,KAAKX,OAFC;AAGfD,IAAAA,KAAK,EAAE,KAAKE;AAHG,GAAjB;AAKA,OAAKD,OAAL,GAAe,EAAf;AACD,CAPD,C,CASA;AACA;AACA;;;AACAZ,WAAW,CAACmB,SAAZ,CAAsBE,IAAtB,GAA6B,UAAUG,KAAV,EAAiB;AAC5C,MAAI,KAAKZ,OAAT,EAAkB;AAChB,SAAKQ,WAAL;AACD;;AAED,OAAKb,MAAL,CAAYc,IAAZ,CAAiBG,KAAjB;AACA,OAAKX,YAAL,GAAoB,KAAKF,KAAzB;AACD,CAPD,C,CASA;AACA;AACA;AACA;;;AACAX,WAAW,CAACmB,SAAZ,CAAsBM,QAAtB,GAAiC,UAAUC,GAAV,EAAeC,GAAf,EAAoB;AACnD,OAAK,IAAIC,CAAC,GAAG,KAAKd,KAAL,CAAWJ,MAAxB,EAAgCkB,CAAC,IAAIF,GAArC,EAA0CE,CAAC,EAA3C,EAA+C;AAC7C,SAAKd,KAAL,CAAWO,IAAX,CAAgB,CAAhB;AACD;;AAED,OAAKP,KAAL,CAAWY,GAAX,IAAkBC,GAAlB;AACD,CAND,C,CAQA;AACA;;;AACA3B,WAAW,CAACmB,SAAZ,CAAsBU,QAAtB,GAAiC,UAAUH,GAAV,EAAe;AAC9C,SAAOA,GAAG,GAAG,KAAKZ,KAAL,CAAWJ,MAAjB,GAA0B,KAAKI,KAAL,CAAWY,GAAX,CAA1B,GAA4C,CAAnD;AACD,CAFD;;AAIAI,MAAM,CAACC,OAAP,GAAiB/B,WAAjB","sourcesContent":["// Inline parser state\n\n'use strict';\n\nfunction StateInline(src, parserInline, options, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.options = options;\n  this.parser = parserInline;\n  this.tokens = outTokens;\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  this.cache = [];        // Stores { start: end } pairs. Useful for backtrack\n                          // optimization of pairs parse (emphasis, strikes).\n\n  // Link parser state vars\n\n  this.isInLabel = false; // Set true when seek link label - we should disable\n                          // \"paired\" rules (emphasis, strikes) to not skip\n                          // tailing `]`\n\n  this.linkLevel = 0;     // Increment for each nesting link. Used to prevent\n                          // nesting in definitions\n\n  this.linkContent = '';  // Temporary storage for link url\n\n  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels\n                                 // (backtrack optimization)\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  this.tokens.push({\n    type: 'text',\n    content: this.pending,\n    level: this.pendingLevel\n  });\n  this.pending = '';\n};\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (token) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  this.tokens.push(token);\n  this.pendingLevel = this.level;\n};\n\n// Store value to cache.\n// !!! Implementation has parser-specific optimizations\n// !!! keys MUST be integer, >= 0; values MUST be integer, > 0\n//\nStateInline.prototype.cacheSet = function (key, val) {\n  for (var i = this.cache.length; i <= key; i++) {\n    this.cache.push(0);\n  }\n\n  this.cache[key] = val;\n};\n\n// Get cache value\n//\nStateInline.prototype.cacheGet = function (key) {\n  return key < this.cache.length ? this.cache[key] : 0;\n};\n\nmodule.exports = StateInline;\n"]},"metadata":{},"sourceType":"script"}