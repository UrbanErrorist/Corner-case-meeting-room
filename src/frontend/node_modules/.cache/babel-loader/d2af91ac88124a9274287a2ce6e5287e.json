{"ast":null,"code":"// Process [links](<to> \"stuff\")\n'use strict';\n\nvar parseLinkLabel = require('../helpers/parse_link_label');\n\nvar parseLinkDestination = require('../helpers/parse_link_destination');\n\nvar parseLinkTitle = require('../helpers/parse_link_title');\n\nvar normalizeReference = require('../helpers/normalize_reference');\n\nmodule.exports = function links(state, silent) {\n  var labelStart,\n      labelEnd,\n      label,\n      href,\n      title,\n      pos,\n      ref,\n      code,\n      isImage = false,\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker === 0x21\n  /* ! */\n  ) {\n      isImage = true;\n      marker = state.src.charCodeAt(++start);\n    }\n\n  if (marker !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  labelStart = start + 1;\n  labelEnd = parseLinkLabel(state, start); // parser failed to find ']', so it's not a valid link\n\n  if (labelEnd < 0) {\n    return false;\n  }\n\n  pos = labelEnd + 1;\n\n  if (pos < max && state.src.charCodeAt(pos) === 0x28\n  /* ( */\n  ) {\n      //\n      // Inline link\n      //\n      // [link](  <href>  \"title\"  )\n      //        ^^ skipping these spaces\n      pos++;\n\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n\n        if (code !== 0x20 && code !== 0x0A) {\n          break;\n        }\n      }\n\n      if (pos >= max) {\n        return false;\n      } // [link](  <href>  \"title\"  )\n      //          ^^^^^^ parsing link destination\n\n\n      start = pos;\n\n      if (parseLinkDestination(state, pos)) {\n        href = state.linkContent;\n        pos = state.pos;\n      } else {\n        href = '';\n      } // [link](  <href>  \"title\"  )\n      //                ^^ skipping these spaces\n\n\n      start = pos;\n\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n\n        if (code !== 0x20 && code !== 0x0A) {\n          break;\n        }\n      } // [link](  <href>  \"title\"  )\n      //                  ^^^^^^^ parsing link title\n\n\n      if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n        title = state.linkContent;\n        pos = state.pos; // [link](  <href>  \"title\"  )\n        //                         ^^ skipping these spaces\n\n        for (; pos < max; pos++) {\n          code = state.src.charCodeAt(pos);\n\n          if (code !== 0x20 && code !== 0x0A) {\n            break;\n          }\n        }\n      } else {\n        title = '';\n      }\n\n      if (pos >= max || state.src.charCodeAt(pos) !== 0x29\n      /* ) */\n      ) {\n          state.pos = oldPos;\n          return false;\n        }\n\n      pos++;\n    } else {\n    //\n    // Link reference\n    //\n    // do not allow nested reference links\n    if (state.linkLevel > 0) {\n      return false;\n    } // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n\n\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n\n      if (code !== 0x20 && code !== 0x0A) {\n        break;\n      }\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B\n    /* [ */\n    ) {\n        start = pos + 1;\n        pos = parseLinkLabel(state, pos);\n\n        if (pos >= 0) {\n          label = state.src.slice(start, pos++);\n        } else {\n          pos = start - 1;\n        }\n      } // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n\n\n    if (!label) {\n      if (typeof label === 'undefined') {\n        pos = labelEnd + 1;\n      }\n\n      label = state.src.slice(labelStart, labelEnd);\n    }\n\n    ref = state.env.references[normalizeReference(label)];\n\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title;\n  } //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n\n\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    if (isImage) {\n      state.push({\n        type: 'image',\n        src: href,\n        title: title,\n        alt: state.src.substr(labelStart, labelEnd - labelStart),\n        level: state.level\n      });\n    } else {\n      state.push({\n        type: 'link_open',\n        href: href,\n        title: title,\n        level: state.level++\n      });\n      state.linkLevel++;\n      state.parser.tokenize(state);\n      state.linkLevel--;\n      state.push({\n        type: 'link_close',\n        level: --state.level\n      });\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};","map":{"version":3,"sources":["/Users/blackhat/Desktop/testingRoom/src/frontend/node_modules/remarkable/lib/rules_inline/links.js"],"names":["parseLinkLabel","require","parseLinkDestination","parseLinkTitle","normalizeReference","module","exports","links","state","silent","labelStart","labelEnd","label","href","title","pos","ref","code","isImage","oldPos","max","posMax","start","marker","src","charCodeAt","level","options","maxNesting","linkContent","linkLevel","slice","env","references","push","type","alt","substr","parser","tokenize"],"mappings":"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","sourcesContent":["// Process [links](<to> \"stuff\")\n\n'use strict';\n\nvar parseLinkLabel       = require('../helpers/parse_link_label');\nvar parseLinkDestination = require('../helpers/parse_link_destination');\nvar parseLinkTitle       = require('../helpers/parse_link_title');\nvar normalizeReference   = require('../helpers/normalize_reference');\n\n\nmodule.exports = function links(state, silent) {\n  var labelStart,\n      labelEnd,\n      label,\n      href,\n      title,\n      pos,\n      ref,\n      code,\n      isImage = false,\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker === 0x21/* ! */) {\n    isImage = true;\n    marker = state.src.charCodeAt(++start);\n  }\n\n  if (marker !== 0x5B/* [ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  labelStart = start + 1;\n  labelEnd = parseLinkLabel(state, start);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    if (parseLinkDestination(state, pos)) {\n      href = state.linkContent;\n      pos = state.pos;\n    } else {\n      href = '';\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n      title = state.linkContent;\n      pos = state.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (code !== 0x20 && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n\n    // do not allow nested reference links\n    if (state.linkLevel > 0) { return false; }\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = start - 1;\n      }\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) {\n      if (typeof label === 'undefined') {\n        pos = labelEnd + 1;\n      }\n      label = state.src.slice(labelStart, labelEnd);\n    }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    if (isImage) {\n      state.push({\n        type: 'image',\n        src: href,\n        title: title,\n        alt: state.src.substr(labelStart, labelEnd - labelStart),\n        level: state.level\n      });\n    } else {\n      state.push({\n        type: 'link_open',\n        href: href,\n        title: title,\n        level: state.level++\n      });\n      state.linkLevel++;\n      state.parser.tokenize(state);\n      state.linkLevel--;\n      state.push({ type: 'link_close', level: --state.level });\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}