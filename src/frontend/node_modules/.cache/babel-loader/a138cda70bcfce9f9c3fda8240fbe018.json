{"ast":null,"code":"(function () {\n  var UtfString;\n\n  if (typeof exports !== 'undefined' && exports !== null) {\n    UtfString = exports;\n  } else if (typeof window !== 'undefined' && window !== null) {\n    if (typeof window.UtfString === 'undefined' || window.UtfString === null) {\n      window.UtfString = {};\n    }\n\n    UtfString = window.UtfString;\n  }\n\n  function factory(obj, graphemeClusterRegexes) {\n    obj.findCharIndex = function (string, byteIndex) {\n      if (byteIndex >= string.length) {\n        return -1;\n      } // optimization: don't iterate unless necessary\n\n\n      if (!containsGraphemeClusterGroup(string)) {\n        return byteIndex;\n      }\n\n      var scanner = createScanner();\n      var charCount = 0;\n\n      while (scanner.exec(string) !== null) {\n        if (scanner.lastIndex > byteIndex) {\n          break;\n        }\n\n        charCount++;\n      }\n\n      return charCount;\n    };\n\n    obj.findByteIndex = function (string, charIndex) {\n      if (charIndex >= this.length(string)) {\n        return -1;\n      }\n\n      return scan(string, createScanner(), charIndex);\n    };\n\n    obj.charAt = function (string, index) {\n      var byteIndex = this.findByteIndex(string, index);\n\n      if (byteIndex < 0 || byteIndex >= string.length) {\n        return '';\n      }\n\n      var characters = string.slice(byteIndex, byteIndex + 8);\n      var match = graphemeClusterRegex.exec(characters);\n\n      if (match === null) {\n        return characters[0];\n      } else {\n        return match[0];\n      }\n    };\n\n    obj.charCodeAt = function (string, index) {\n      var byteIndex = findSurrogateByteIndex(string, index);\n\n      if (byteIndex < 0) {\n        return NaN;\n      }\n\n      var code = string.charCodeAt(byteIndex);\n\n      if (0xD800 <= code && code <= 0xDBFF) {\n        var hi = code;\n        var low = string.charCodeAt(byteIndex + 1);\n        return (hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000;\n      }\n\n      return code;\n    };\n\n    obj.fromCharCode = function (charCode) {\n      if (charCode > 0xFFFF) {\n        charCode -= 0x10000;\n        return String.fromCharCode(0xD800 + (charCode >> 10), 0xDC00 + (charCode & 0x3FF));\n      } else {\n        return String.fromCharCode(charCode);\n      }\n    };\n\n    obj.indexOf = function (string, searchValue, start) {\n      if (typeof start === 'undefined' || start === null) {\n        start = 0;\n      }\n\n      var startByteIndex = this.findByteIndex(string, start);\n      var index = string.indexOf(searchValue, startByteIndex);\n\n      if (index < 0) {\n        return -1;\n      } else {\n        return this.findCharIndex(string, index);\n      }\n    };\n\n    obj.lastIndexOf = function (string, searchValue, start) {\n      var index;\n\n      if (typeof start === 'undefined' || start === null) {\n        index = string.lastIndexOf(searchValue);\n      } else {\n        var startByteIndex = this.findByteIndex(string, start);\n        index = string.lastIndexOf(searchValue, startByteIndex);\n      }\n\n      if (index < 0) {\n        return -1;\n      } else {\n        return this.findCharIndex(string, index);\n      }\n    };\n\n    obj.slice = function (string, start, finish) {\n      var startByteIndex = this.findByteIndex(string, start);\n      var finishByteIndex;\n\n      if (startByteIndex < 0) {\n        startByteIndex = string.length;\n      }\n\n      if (typeof finish === 'undefined' || finish === null) {\n        finishByteIndex = string.length;\n      } else {\n        finishByteIndex = this.findByteIndex(string, finish);\n\n        if (finishByteIndex < 0) {\n          finishByteIndex = string.length;\n        }\n      }\n\n      return string.slice(startByteIndex, finishByteIndex);\n    };\n\n    obj.substr = function (string, start, length) {\n      if (start < 0) {\n        start = this.length(string) + start;\n      }\n\n      if (typeof length === 'undefined' || length === null) {\n        return this.slice(string, start);\n      } else {\n        return this.slice(string, start, start + length);\n      }\n    }; // they do the same thing\n\n\n    obj.substring = obj.slice;\n\n    obj.length = function (string) {\n      // findCharIndex will return -1 if string is empty, so add 1\n      return this.findCharIndex(string, string.length - 1) + 1;\n    };\n\n    obj.stringToCodePoints = function (string) {\n      var result = [];\n\n      for (var i = 0; i < string.length; i++) {\n        codePoint = this.charCodeAt(string, i);\n\n        if (!codePoint) {\n          break;\n        }\n\n        result.push(codePoint);\n      }\n\n      return result;\n    };\n\n    obj.codePointsToString = function (arr) {\n      var chars = [];\n\n      for (var i = 0; i < arr.length; i++) {\n        chars.push(this.fromCharCode(arr[i]));\n      }\n\n      return chars.join('');\n    };\n\n    obj.stringToBytes = function (string) {\n      var result = [];\n\n      for (var i = 0; i < string.length; i++) {\n        var chr = string.charCodeAt(i);\n        var byteArray = [];\n\n        while (chr > 0) {\n          byteArray.push(chr & 0xFF);\n          chr >>= 8;\n        } // all utf-16 characters are two bytes\n\n\n        if (byteArray.length == 1) {\n          byteArray.push(0);\n        } // assume big-endian\n\n\n        result = result.concat(byteArray.reverse());\n      }\n\n      return result;\n    };\n\n    obj.bytesToString = function (arr) {\n      var result = [];\n\n      for (var i = 0; i < arr.length; i += 2) {\n        var hi = arr[i];\n        var low = arr[i + 1];\n        var combined = hi << 8 | low;\n        result.push(String.fromCharCode(combined));\n      }\n\n      return result.join('');\n    };\n\n    obj.stringToCharArray = function (string) {\n      var result = [];\n      var scanner = createScanner();\n\n      do {\n        var match = scanner.exec(string);\n\n        if (match === null) {\n          break;\n        }\n\n        result.push(match[0]);\n      } while (match !== null);\n\n      return result;\n    };\n\n    function findSurrogateByteIndex(string, charIndex) {\n      return scan(string, new RegExp(surrogatePairs.source, 'g'), charIndex);\n    }\n\n    function scan(string, scanner, charIndex) {\n      // optimization: don't iterate unless it's necessary\n      if (!containsGraphemeClusterGroup(string)) {\n        return charIndex;\n      }\n\n      var byteIndex = 0;\n      var curCharIndex = 0;\n\n      while (true) {\n        var match = scanner.exec(string);\n        var nextIdx;\n\n        if (match) {\n          nextIdx = match.index;\n        } else {\n          nextIdx = string.length;\n        }\n\n        while (curCharIndex < charIndex) {\n          if (byteIndex == nextIdx) {\n            if (curCharIndex < charIndex) {\n              curCharIndex++;\n\n              if (match) {\n                byteIndex += match[0].length;\n              } else {\n                byteIndex++;\n              }\n            }\n\n            break;\n          }\n\n          byteIndex++;\n          curCharIndex++;\n        }\n\n        if (curCharIndex == charIndex) {\n          break;\n        } else if (byteIndex >= string.length || !match) {\n          return -1;\n        }\n      }\n\n      return byteIndex;\n    }\n\n    function containsGraphemeClusterGroup(string) {\n      return graphemeClusterRegex.test(string);\n    }\n\n    function createScanner(extraSources, modifiers) {\n      if (extraSources == undefined) {\n        extraSources = ['[^]'];\n      }\n\n      if (modifiers == undefined) {\n        modifiers = 'g';\n      }\n\n      var sources = [];\n      graphemeClusterRegexes.forEach(function (re) {\n        sources.push(re.source);\n      });\n      sources.push(surrogatePairs.source);\n      sources = sources.concat(extraSources);\n      return new RegExp(sources.join('|'), modifiers);\n    }\n\n    var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/;\n    var graphemeClusterRegex = createScanner([], '');\n  }\n\n  var regionalIndicatorPairs = /\\uD83C[\\uDDE6-\\uDDFF]\\uD83C[\\uDDE6-\\uDDFF]/;\n  UtfString.visual = {};\n  factory(UtfString, []);\n  factory(UtfString.visual, [regionalIndicatorPairs]);\n})();","map":{"version":3,"sources":["/Users/blackhat/Desktop/testingRoom/src/frontend/node_modules/utfstring/utfstring.js"],"names":["UtfString","exports","window","factory","obj","graphemeClusterRegexes","findCharIndex","string","byteIndex","length","containsGraphemeClusterGroup","scanner","createScanner","charCount","exec","lastIndex","findByteIndex","charIndex","scan","charAt","index","characters","slice","match","graphemeClusterRegex","charCodeAt","findSurrogateByteIndex","NaN","code","hi","low","fromCharCode","charCode","String","indexOf","searchValue","start","startByteIndex","lastIndexOf","finish","finishByteIndex","substr","substring","stringToCodePoints","result","i","codePoint","push","codePointsToString","arr","chars","join","stringToBytes","chr","byteArray","concat","reverse","bytesToString","combined","stringToCharArray","RegExp","surrogatePairs","source","curCharIndex","nextIdx","test","extraSources","modifiers","undefined","sources","forEach","re","regionalIndicatorPairs","visual"],"mappings":"AAAA,CAAC,YAAW;AACV,MAAIA,SAAJ;;AAEA,MAAI,OAAOC,OAAP,KAAmB,WAAnB,IAAkCA,OAAO,KAAK,IAAlD,EAAwD;AACtDD,IAAAA,SAAS,GAAGC,OAAZ;AACD,GAFD,MAEO,IAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,KAAK,IAAhD,EAAsD;AAC3D,QAAK,OAAOA,MAAM,CAACF,SAAd,KAA4B,WAA7B,IAA8CE,MAAM,CAACF,SAAP,KAAqB,IAAvE,EAA8E;AAC5EE,MAAAA,MAAM,CAACF,SAAP,GAAmB,EAAnB;AACD;;AAEDA,IAAAA,SAAS,GAAGE,MAAM,CAACF,SAAnB;AACD;;AAED,WAASG,OAAT,CAAiBC,GAAjB,EAAsBC,sBAAtB,EAA8C;AAC5CD,IAAAA,GAAG,CAACE,aAAJ,GAAoB,UAASC,MAAT,EAAiBC,SAAjB,EAA4B;AAC9C,UAAIA,SAAS,IAAID,MAAM,CAACE,MAAxB,EAAgC;AAC9B,eAAO,CAAC,CAAR;AACD,OAH6C,CAK9C;;;AACA,UAAI,CAACC,4BAA4B,CAACH,MAAD,CAAjC,EAA2C;AACzC,eAAOC,SAAP;AACD;;AAED,UAAIG,OAAO,GAAGC,aAAa,EAA3B;AACA,UAAIC,SAAS,GAAG,CAAhB;;AAEA,aAAOF,OAAO,CAACG,IAAR,CAAaP,MAAb,MAAyB,IAAhC,EAAsC;AACpC,YAAII,OAAO,CAACI,SAAR,GAAoBP,SAAxB,EAAmC;AACjC;AACD;;AAEDK,QAAAA,SAAS;AACV;;AAED,aAAOA,SAAP;AACD,KAtBD;;AAwBAT,IAAAA,GAAG,CAACY,aAAJ,GAAoB,UAAST,MAAT,EAAiBU,SAAjB,EAA4B;AAC9C,UAAIA,SAAS,IAAI,KAAKR,MAAL,CAAYF,MAAZ,CAAjB,EAAsC;AACpC,eAAO,CAAC,CAAR;AACD;;AAED,aAAOW,IAAI,CAACX,MAAD,EAASK,aAAa,EAAtB,EAA0BK,SAA1B,CAAX;AACD,KAND;;AAQAb,IAAAA,GAAG,CAACe,MAAJ,GAAa,UAASZ,MAAT,EAAiBa,KAAjB,EAAwB;AACnC,UAAIZ,SAAS,GAAG,KAAKQ,aAAL,CAAmBT,MAAnB,EAA2Ba,KAA3B,CAAhB;;AAEA,UAAKZ,SAAS,GAAG,CAAb,IAAoBA,SAAS,IAAID,MAAM,CAACE,MAA5C,EAAqD;AACnD,eAAO,EAAP;AACD;;AAED,UAAIY,UAAU,GAAGd,MAAM,CAACe,KAAP,CAAad,SAAb,EAAwBA,SAAS,GAAG,CAApC,CAAjB;AACA,UAAIe,KAAK,GAAGC,oBAAoB,CAACV,IAArB,CAA0BO,UAA1B,CAAZ;;AAEA,UAAIE,KAAK,KAAK,IAAd,EAAoB;AAClB,eAAOF,UAAU,CAAC,CAAD,CAAjB;AACD,OAFD,MAEO;AACL,eAAOE,KAAK,CAAC,CAAD,CAAZ;AACD;AACF,KAfD;;AAiBAnB,IAAAA,GAAG,CAACqB,UAAJ,GAAiB,UAASlB,MAAT,EAAiBa,KAAjB,EAAwB;AACvC,UAAIZ,SAAS,GAAGkB,sBAAsB,CAACnB,MAAD,EAASa,KAAT,CAAtC;;AAEA,UAAIZ,SAAS,GAAG,CAAhB,EAAmB;AACjB,eAAOmB,GAAP;AACD;;AAED,UAAIC,IAAI,GAAGrB,MAAM,CAACkB,UAAP,CAAkBjB,SAAlB,CAAX;;AAEA,UAAK,UAAUoB,IAAX,IAAqBA,IAAI,IAAI,MAAjC,EAA0C;AACxC,YAAIC,EAAE,GAAGD,IAAT;AACA,YAAIE,GAAG,GAAGvB,MAAM,CAACkB,UAAP,CAAkBjB,SAAS,GAAG,CAA9B,CAAV;AACA,eAAQ,CAACqB,EAAE,GAAG,MAAN,IAAgB,KAAjB,IAA2BC,GAAG,GAAG,MAAjC,IAA2C,OAAlD;AACD;;AAED,aAAOF,IAAP;AACD,KAhBD;;AAkBAxB,IAAAA,GAAG,CAAC2B,YAAJ,GAAmB,UAASC,QAAT,EAAmB;AACpC,UAAIA,QAAQ,GAAG,MAAf,EAAuB;AACrBA,QAAAA,QAAQ,IAAI,OAAZ;AAEA,eAAOC,MAAM,CAACF,YAAP,CACL,UAAUC,QAAQ,IAAI,EAAtB,CADK,EACsB,UAAUA,QAAQ,GAAG,KAArB,CADtB,CAAP;AAGD,OAND,MAMO;AACL,eAAOC,MAAM,CAACF,YAAP,CAAoBC,QAApB,CAAP;AACD;AACF,KAVD;;AAYA5B,IAAAA,GAAG,CAAC8B,OAAJ,GAAc,UAAS3B,MAAT,EAAiB4B,WAAjB,EAA8BC,KAA9B,EAAqC;AACjD,UAAK,OAAOA,KAAP,KAAiB,WAAlB,IAAmCA,KAAK,KAAK,IAAjD,EAAwD;AACtDA,QAAAA,KAAK,GAAG,CAAR;AACD;;AAED,UAAIC,cAAc,GAAG,KAAKrB,aAAL,CAAmBT,MAAnB,EAA2B6B,KAA3B,CAArB;AACA,UAAIhB,KAAK,GAAGb,MAAM,CAAC2B,OAAP,CAAeC,WAAf,EAA4BE,cAA5B,CAAZ;;AAEA,UAAIjB,KAAK,GAAG,CAAZ,EAAe;AACb,eAAO,CAAC,CAAR;AACD,OAFD,MAEO;AACL,eAAO,KAAKd,aAAL,CAAmBC,MAAnB,EAA2Ba,KAA3B,CAAP;AACD;AACF,KAbD;;AAeAhB,IAAAA,GAAG,CAACkC,WAAJ,GAAkB,UAAS/B,MAAT,EAAiB4B,WAAjB,EAA8BC,KAA9B,EAAqC;AACrD,UAAIhB,KAAJ;;AAEA,UAAK,OAAOgB,KAAP,KAAiB,WAAlB,IAAmCA,KAAK,KAAK,IAAjD,EAAwD;AACtDhB,QAAAA,KAAK,GAAGb,MAAM,CAAC+B,WAAP,CAAmBH,WAAnB,CAAR;AACD,OAFD,MAEO;AACL,YAAIE,cAAc,GAAG,KAAKrB,aAAL,CAAmBT,MAAnB,EAA2B6B,KAA3B,CAArB;AACAhB,QAAAA,KAAK,GAAGb,MAAM,CAAC+B,WAAP,CAAmBH,WAAnB,EAAgCE,cAAhC,CAAR;AACD;;AAED,UAAIjB,KAAK,GAAG,CAAZ,EAAe;AACb,eAAO,CAAC,CAAR;AACD,OAFD,MAEO;AACL,eAAO,KAAKd,aAAL,CAAmBC,MAAnB,EAA2Ba,KAA3B,CAAP;AACD;AACF,KAfD;;AAiBAhB,IAAAA,GAAG,CAACkB,KAAJ,GAAY,UAASf,MAAT,EAAiB6B,KAAjB,EAAwBG,MAAxB,EAAgC;AAC1C,UAAIF,cAAc,GAAG,KAAKrB,aAAL,CAAmBT,MAAnB,EAA2B6B,KAA3B,CAArB;AACA,UAAII,eAAJ;;AAEA,UAAIH,cAAc,GAAG,CAArB,EAAwB;AACtBA,QAAAA,cAAc,GAAG9B,MAAM,CAACE,MAAxB;AACD;;AAED,UAAK,OAAO8B,MAAP,KAAkB,WAAnB,IAAoCA,MAAM,KAAK,IAAnD,EAA0D;AACxDC,QAAAA,eAAe,GAAGjC,MAAM,CAACE,MAAzB;AACD,OAFD,MAEO;AACL+B,QAAAA,eAAe,GAAG,KAAKxB,aAAL,CAAmBT,MAAnB,EAA2BgC,MAA3B,CAAlB;;AAEA,YAAIC,eAAe,GAAG,CAAtB,EAAyB;AACvBA,UAAAA,eAAe,GAAGjC,MAAM,CAACE,MAAzB;AACD;AACF;;AAED,aAAOF,MAAM,CAACe,KAAP,CAAae,cAAb,EAA6BG,eAA7B,CAAP;AACD,KAnBD;;AAqBApC,IAAAA,GAAG,CAACqC,MAAJ,GAAa,UAASlC,MAAT,EAAiB6B,KAAjB,EAAwB3B,MAAxB,EAAgC;AAC3C,UAAI2B,KAAK,GAAG,CAAZ,EAAe;AACbA,QAAAA,KAAK,GAAG,KAAK3B,MAAL,CAAYF,MAAZ,IAAsB6B,KAA9B;AACD;;AAED,UAAK,OAAO3B,MAAP,KAAkB,WAAnB,IAAoCA,MAAM,KAAK,IAAnD,EAA0D;AACxD,eAAO,KAAKa,KAAL,CAAWf,MAAX,EAAmB6B,KAAnB,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAKd,KAAL,CAAWf,MAAX,EAAmB6B,KAAnB,EAA0BA,KAAK,GAAG3B,MAAlC,CAAP;AACD;AACF,KAVD,CArI4C,CAiJ5C;;;AACAL,IAAAA,GAAG,CAACsC,SAAJ,GAAgBtC,GAAG,CAACkB,KAApB;;AAEAlB,IAAAA,GAAG,CAACK,MAAJ,GAAa,UAASF,MAAT,EAAiB;AAC5B;AACA,aAAO,KAAKD,aAAL,CAAmBC,MAAnB,EAA2BA,MAAM,CAACE,MAAP,GAAgB,CAA3C,IAAgD,CAAvD;AACD,KAHD;;AAKAL,IAAAA,GAAG,CAACuC,kBAAJ,GAAyB,UAASpC,MAAT,EAAiB;AACxC,UAAIqC,MAAM,GAAG,EAAb;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtC,MAAM,CAACE,MAA3B,EAAmCoC,CAAC,EAApC,EAAyC;AACvCC,QAAAA,SAAS,GAAG,KAAKrB,UAAL,CAAgBlB,MAAhB,EAAwBsC,CAAxB,CAAZ;;AAEA,YAAI,CAACC,SAAL,EAAgB;AACd;AACD;;AAEDF,QAAAA,MAAM,CAACG,IAAP,CAAYD,SAAZ;AACD;;AAED,aAAOF,MAAP;AACD,KAdD;;AAgBAxC,IAAAA,GAAG,CAAC4C,kBAAJ,GAAyB,UAASC,GAAT,EAAc;AACrC,UAAIC,KAAK,GAAG,EAAZ;;AAEA,WAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,GAAG,CAACxC,MAAxB,EAAgCoC,CAAC,EAAjC,EAAsC;AACpCK,QAAAA,KAAK,CAACH,IAAN,CAAW,KAAKhB,YAAL,CAAkBkB,GAAG,CAACJ,CAAD,CAArB,CAAX;AACD;;AAED,aAAOK,KAAK,CAACC,IAAN,CAAW,EAAX,CAAP;AACD,KARD;;AAUA/C,IAAAA,GAAG,CAACgD,aAAJ,GAAoB,UAAS7C,MAAT,EAAiB;AACnC,UAAIqC,MAAM,GAAG,EAAb;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtC,MAAM,CAACE,MAA3B,EAAmCoC,CAAC,EAApC,EAAyC;AACvC,YAAIQ,GAAG,GAAG9C,MAAM,CAACkB,UAAP,CAAkBoB,CAAlB,CAAV;AACA,YAAIS,SAAS,GAAG,EAAhB;;AAEA,eAAOD,GAAG,GAAG,CAAb,EAAgB;AACdC,UAAAA,SAAS,CAACP,IAAV,CAAeM,GAAG,GAAG,IAArB;AACAA,UAAAA,GAAG,KAAK,CAAR;AACD,SAPsC,CASvC;;;AACA,YAAIC,SAAS,CAAC7C,MAAV,IAAoB,CAAxB,EAA2B;AACzB6C,UAAAA,SAAS,CAACP,IAAV,CAAe,CAAf;AACD,SAZsC,CAcvC;;;AACAH,QAAAA,MAAM,GAAGA,MAAM,CAACW,MAAP,CAAcD,SAAS,CAACE,OAAV,EAAd,CAAT;AACD;;AAED,aAAOZ,MAAP;AACD,KAtBD;;AAwBAxC,IAAAA,GAAG,CAACqD,aAAJ,GAAoB,UAASR,GAAT,EAAc;AAChC,UAAIL,MAAM,GAAG,EAAb;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,GAAG,CAACxC,MAAxB,EAAgCoC,CAAC,IAAI,CAArC,EAAwC;AACtC,YAAIhB,EAAE,GAAGoB,GAAG,CAACJ,CAAD,CAAZ;AACA,YAAIf,GAAG,GAAGmB,GAAG,CAACJ,CAAC,GAAG,CAAL,CAAb;AACA,YAAIa,QAAQ,GAAI7B,EAAE,IAAI,CAAP,GAAYC,GAA3B;AACAc,QAAAA,MAAM,CAACG,IAAP,CAAYd,MAAM,CAACF,YAAP,CAAoB2B,QAApB,CAAZ;AACD;;AAED,aAAOd,MAAM,CAACO,IAAP,CAAY,EAAZ,CAAP;AACD,KAXD;;AAaA/C,IAAAA,GAAG,CAACuD,iBAAJ,GAAwB,UAASpD,MAAT,EAAiB;AACvC,UAAIqC,MAAM,GAAG,EAAb;AACA,UAAIjC,OAAO,GAAGC,aAAa,EAA3B;;AAEA,SAAG;AACD,YAAIW,KAAK,GAAGZ,OAAO,CAACG,IAAR,CAAaP,MAAb,CAAZ;;AAEA,YAAIgB,KAAK,KAAK,IAAd,EAAoB;AAClB;AACD;;AAEDqB,QAAAA,MAAM,CAACG,IAAP,CAAYxB,KAAK,CAAC,CAAD,CAAjB;AACD,OARD,QAQQA,KAAK,KAAK,IARlB;;AAUA,aAAOqB,MAAP;AACD,KAfD;;AAiBA,aAASlB,sBAAT,CAAgCnB,MAAhC,EAAwCU,SAAxC,EAAmD;AACjD,aAAOC,IAAI,CAACX,MAAD,EAAS,IAAIqD,MAAJ,CAAWC,cAAc,CAACC,MAA1B,EAAkC,GAAlC,CAAT,EAAiD7C,SAAjD,CAAX;AACD;;AAED,aAASC,IAAT,CAAcX,MAAd,EAAsBI,OAAtB,EAA+BM,SAA/B,EAA0C;AACxC;AACA,UAAI,CAACP,4BAA4B,CAACH,MAAD,CAAjC,EAA2C;AACzC,eAAOU,SAAP;AACD;;AAED,UAAIT,SAAS,GAAG,CAAhB;AACA,UAAIuD,YAAY,GAAG,CAAnB;;AAEA,aAAO,IAAP,EAAa;AACX,YAAIxC,KAAK,GAAGZ,OAAO,CAACG,IAAR,CAAaP,MAAb,CAAZ;AACA,YAAIyD,OAAJ;;AAEA,YAAIzC,KAAJ,EAAW;AACTyC,UAAAA,OAAO,GAAGzC,KAAK,CAACH,KAAhB;AACD,SAFD,MAEO;AACL4C,UAAAA,OAAO,GAAGzD,MAAM,CAACE,MAAjB;AACD;;AAED,eAAOsD,YAAY,GAAG9C,SAAtB,EAAiC;AAC/B,cAAIT,SAAS,IAAIwD,OAAjB,EAA0B;AACxB,gBAAID,YAAY,GAAG9C,SAAnB,EAA8B;AAC5B8C,cAAAA,YAAY;;AAEZ,kBAAIxC,KAAJ,EAAW;AACTf,gBAAAA,SAAS,IAAIe,KAAK,CAAC,CAAD,CAAL,CAASd,MAAtB;AACD,eAFD,MAEO;AACLD,gBAAAA,SAAS;AACV;AACF;;AAED;AACD;;AAEDA,UAAAA,SAAS;AACTuD,UAAAA,YAAY;AACb;;AAED,YAAIA,YAAY,IAAI9C,SAApB,EAA+B;AAC7B;AACD,SAFD,MAEO,IAAIT,SAAS,IAAID,MAAM,CAACE,MAApB,IAA8B,CAACc,KAAnC,EAA0C;AAC/C,iBAAO,CAAC,CAAR;AACD;AACF;;AAED,aAAOf,SAAP;AACD;;AAED,aAASE,4BAAT,CAAsCH,MAAtC,EAA8C;AAC5C,aAAOiB,oBAAoB,CAACyC,IAArB,CAA0B1D,MAA1B,CAAP;AACD;;AAED,aAASK,aAAT,CAAuBsD,YAAvB,EAAqCC,SAArC,EAAgD;AAC9C,UAAID,YAAY,IAAIE,SAApB,EAA+B;AAC7BF,QAAAA,YAAY,GAAG,CAAC,KAAD,CAAf;AACD;;AAED,UAAIC,SAAS,IAAIC,SAAjB,EAA4B;AAC1BD,QAAAA,SAAS,GAAG,GAAZ;AACD;;AAED,UAAIE,OAAO,GAAG,EAAd;AAEAhE,MAAAA,sBAAsB,CAACiE,OAAvB,CAA+B,UAASC,EAAT,EAAa;AAC1CF,QAAAA,OAAO,CAACtB,IAAR,CAAawB,EAAE,CAACT,MAAhB;AACD,OAFD;AAIAO,MAAAA,OAAO,CAACtB,IAAR,CAAac,cAAc,CAACC,MAA5B;AACAO,MAAAA,OAAO,GAAGA,OAAO,CAACd,MAAR,CAAeW,YAAf,CAAV;AAEA,aAAO,IAAIN,MAAJ,CAAWS,OAAO,CAAClB,IAAR,CAAa,GAAb,CAAX,EAA8BgB,SAA9B,CAAP;AACD;;AAED,QAAIN,cAAc,GAAG,gCAArB;AACA,QAAIrC,oBAAoB,GAAGZ,aAAa,CAAC,EAAD,EAAK,EAAL,CAAxC;AACD;;AAED,MAAI4D,sBAAsB,GAAG,4CAA7B;AAEAxE,EAAAA,SAAS,CAACyE,MAAV,GAAmB,EAAnB;AAEAtE,EAAAA,OAAO,CAACH,SAAD,EAAY,EAAZ,CAAP;AACAG,EAAAA,OAAO,CAACH,SAAS,CAACyE,MAAX,EAAmB,CAACD,sBAAD,CAAnB,CAAP;AACD,CA7UD","sourcesContent":["(function() {\n  var UtfString;\n\n  if (typeof exports !== 'undefined' && exports !== null) {\n    UtfString = exports;\n  } else if (typeof window !== 'undefined' && window !== null) {\n    if ((typeof window.UtfString === 'undefined') || (window.UtfString === null)) {\n      window.UtfString = {};\n    }\n\n    UtfString = window.UtfString;\n  }\n\n  function factory(obj, graphemeClusterRegexes) {\n    obj.findCharIndex = function(string, byteIndex) {\n      if (byteIndex >= string.length) {\n        return -1;\n      }\n\n      // optimization: don't iterate unless necessary\n      if (!containsGraphemeClusterGroup(string)) {\n        return byteIndex;\n      }\n\n      var scanner = createScanner();\n      var charCount = 0;\n\n      while (scanner.exec(string) !== null) {\n        if (scanner.lastIndex > byteIndex) {\n          break;\n        }\n\n        charCount ++;\n      }\n\n      return charCount;\n    };\n\n    obj.findByteIndex = function(string, charIndex) {\n      if (charIndex >= this.length(string)) {\n        return -1;\n      }\n\n      return scan(string, createScanner(), charIndex);\n    };\n\n    obj.charAt = function(string, index) {\n      var byteIndex = this.findByteIndex(string, index);\n\n      if ((byteIndex < 0) || (byteIndex >= string.length)) {\n        return '';\n      }\n\n      var characters = string.slice(byteIndex, byteIndex + 8);\n      var match = graphemeClusterRegex.exec(characters);\n\n      if (match === null) {\n        return characters[0];\n      } else {\n        return match[0];\n      }\n    };\n\n    obj.charCodeAt = function(string, index) {\n      var byteIndex = findSurrogateByteIndex(string, index);\n\n      if (byteIndex < 0) {\n        return NaN;\n      }\n\n      var code = string.charCodeAt(byteIndex);\n\n      if ((0xD800 <= code) && (code <= 0xDBFF)) {\n        var hi = code;\n        var low = string.charCodeAt(byteIndex + 1);\n        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n      }\n\n      return code;\n    };\n\n    obj.fromCharCode = function(charCode) {\n      if (charCode > 0xFFFF) {\n        charCode -= 0x10000;\n\n        return String.fromCharCode(\n          0xD800 + (charCode >> 10), 0xDC00 + (charCode & 0x3FF)\n        );\n      } else {\n        return String.fromCharCode(charCode);\n      }\n    };\n\n    obj.indexOf = function(string, searchValue, start) {\n      if ((typeof start === 'undefined') || (start === null)) {\n        start = 0;\n      }\n\n      var startByteIndex = this.findByteIndex(string, start);\n      var index = string.indexOf(searchValue, startByteIndex);\n\n      if (index < 0) {\n        return -1\n      } else {\n        return this.findCharIndex(string, index);\n      }\n    };\n\n    obj.lastIndexOf = function(string, searchValue, start) {\n      var index;\n\n      if ((typeof start === 'undefined') || (start === null)) {\n        index = string.lastIndexOf(searchValue);\n      } else {\n        var startByteIndex = this.findByteIndex(string, start);\n        index = string.lastIndexOf(searchValue, startByteIndex);\n      }\n\n      if (index < 0) {\n        return -1;\n      } else {\n        return this.findCharIndex(string, index);\n      }\n    };\n\n    obj.slice = function(string, start, finish) {\n      var startByteIndex = this.findByteIndex(string, start);\n      var finishByteIndex;\n\n      if (startByteIndex < 0) {\n        startByteIndex = string.length;\n      }\n\n      if ((typeof finish === 'undefined') || (finish === null)) {\n        finishByteIndex = string.length;\n      } else {\n        finishByteIndex = this.findByteIndex(string, finish);\n\n        if (finishByteIndex < 0) {\n          finishByteIndex = string.length;\n        }\n      }\n\n      return string.slice(startByteIndex, finishByteIndex);\n    };\n\n    obj.substr = function(string, start, length) {\n      if (start < 0) {\n        start = this.length(string) + start;\n      }\n\n      if ((typeof length === 'undefined') || (length === null)) {\n        return this.slice(string, start);\n      } else {\n        return this.slice(string, start, start + length);\n      }\n    };\n\n    // they do the same thing\n    obj.substring = obj.slice;\n\n    obj.length = function(string) {\n      // findCharIndex will return -1 if string is empty, so add 1\n      return this.findCharIndex(string, string.length - 1) + 1;\n    };\n\n    obj.stringToCodePoints = function(string) {\n      var result = [];\n\n      for (var i = 0; i < string.length; i ++) {\n        codePoint = this.charCodeAt(string, i);\n\n        if (!codePoint) {\n          break;\n        }\n\n        result.push(codePoint);\n      }\n\n      return result;\n    };\n\n    obj.codePointsToString = function(arr) {\n      var chars = [];\n\n      for (var i = 0; i < arr.length; i ++) {\n        chars.push(this.fromCharCode(arr[i]));\n      }\n\n      return chars.join('');\n    };\n\n    obj.stringToBytes = function(string) {\n      var result = [];\n\n      for (var i = 0; i < string.length; i ++) {\n        var chr = string.charCodeAt(i);\n        var byteArray = [];\n\n        while (chr > 0) {\n          byteArray.push(chr & 0xFF);\n          chr >>= 8;\n        }\n\n        // all utf-16 characters are two bytes\n        if (byteArray.length == 1) {\n          byteArray.push(0);\n        }\n\n        // assume big-endian\n        result = result.concat(byteArray.reverse());\n      }\n\n      return result;\n    };\n\n    obj.bytesToString = function(arr) {\n      var result = [];\n\n      for (var i = 0; i < arr.length; i += 2) {\n        var hi = arr[i];\n        var low = arr[i + 1];\n        var combined = (hi << 8) | low;\n        result.push(String.fromCharCode(combined));\n      }\n\n      return result.join('');\n    };\n\n    obj.stringToCharArray = function(string) {\n      var result = [];\n      var scanner = createScanner();\n\n      do {\n        var match = scanner.exec(string);\n\n        if (match === null) {\n          break;\n        }\n\n        result.push(match[0]);\n      } while(match !== null);\n\n      return result;\n    };\n\n    function findSurrogateByteIndex(string, charIndex) {\n      return scan(string, new RegExp(surrogatePairs.source, 'g'), charIndex);\n    }\n\n    function scan(string, scanner, charIndex) {\n      // optimization: don't iterate unless it's necessary\n      if (!containsGraphemeClusterGroup(string)) {\n        return charIndex;\n      }\n\n      var byteIndex = 0;\n      var curCharIndex = 0;\n\n      while (true) {\n        var match = scanner.exec(string);\n        var nextIdx;\n\n        if (match) {\n          nextIdx = match.index;\n        } else {\n          nextIdx = string.length;\n        }\n\n        while (curCharIndex < charIndex) {\n          if (byteIndex == nextIdx) {\n            if (curCharIndex < charIndex) {\n              curCharIndex ++;\n\n              if (match) {\n                byteIndex += match[0].length;\n              } else {\n                byteIndex ++;\n              }\n            }\n\n            break;\n          }\n\n          byteIndex ++;\n          curCharIndex ++;\n        }\n\n        if (curCharIndex == charIndex) {\n          break;\n        } else if (byteIndex >= string.length || !match) {\n          return -1;\n        }\n      }\n\n      return byteIndex;\n    }\n\n    function containsGraphemeClusterGroup(string) {\n      return graphemeClusterRegex.test(string);\n    }\n\n    function createScanner(extraSources, modifiers) {\n      if (extraSources == undefined) {\n        extraSources = ['[^]'];\n      }\n\n      if (modifiers == undefined) {\n        modifiers = 'g';\n      }\n\n      var sources = [];\n\n      graphemeClusterRegexes.forEach(function(re) {\n        sources.push(re.source);\n      });\n\n      sources.push(surrogatePairs.source);\n      sources = sources.concat(extraSources);\n\n      return new RegExp(sources.join('|'), modifiers);\n    }\n\n    var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/;\n    var graphemeClusterRegex = createScanner([], '');\n  }\n\n  var regionalIndicatorPairs = /\\uD83C[\\uDDE6-\\uDDFF]\\uD83C[\\uDDE6-\\uDDFF]/;\n\n  UtfString.visual = {};\n\n  factory(UtfString, []);\n  factory(UtfString.visual, [regionalIndicatorPairs]);\n})();\n"]},"metadata":{},"sourceType":"script"}