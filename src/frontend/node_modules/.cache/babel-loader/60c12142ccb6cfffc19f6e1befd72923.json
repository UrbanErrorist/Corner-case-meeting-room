{"ast":null,"code":"/* eslint max-statements: 0 */\n// Support for functions returning promise\n\"use strict\";\n\nvar objectMap = require(\"es5-ext/object/map\"),\n    primitiveSet = require(\"es5-ext/object/primitive-set\"),\n    ensureString = require(\"es5-ext/object/validate-stringifiable-value\"),\n    toShortString = require(\"es5-ext/to-short-string-representation\"),\n    isPromise = require(\"is-promise\"),\n    nextTick = require(\"next-tick\");\n\nvar create = Object.create,\n    supportedModes = primitiveSet(\"then\", \"then:finally\", \"done\", \"done:finally\");\n\nrequire(\"../lib/registered-extensions\").promise = function (mode, conf) {\n  var waiting = create(null),\n      cache = create(null),\n      promises = create(null);\n\n  if (mode === true) {\n    mode = null;\n  } else {\n    mode = ensureString(mode);\n\n    if (!supportedModes[mode]) {\n      throw new TypeError(\"'\" + toShortString(mode) + \"' is not valid promise mode\");\n    }\n  } // After not from cache call\n\n\n  conf.on(\"set\", function (id, ignore, promise) {\n    var isFailed = false;\n\n    if (!isPromise(promise)) {\n      // Non promise result\n      cache[id] = promise;\n      conf.emit(\"setasync\", id, 1);\n      return;\n    }\n\n    waiting[id] = 1;\n    promises[id] = promise;\n\n    var onSuccess = function (result) {\n      var count = waiting[id];\n\n      if (isFailed) {\n        throw new Error(\"Memoizee error: Detected unordered then|done & finally resolution, which \" + \"in turn makes proper detection of success/failure impossible (when in \" + \"'done:finally' mode)\\n\" + \"Consider to rely on 'then' or 'done' mode instead.\");\n      }\n\n      if (!count) return; // Deleted from cache before resolved\n\n      delete waiting[id];\n      cache[id] = result;\n      conf.emit(\"setasync\", id, count);\n    };\n\n    var onFailure = function () {\n      isFailed = true;\n      if (!waiting[id]) return; // Deleted from cache (or succeed in case of finally)\n\n      delete waiting[id];\n      delete promises[id];\n      conf.delete(id);\n    };\n\n    var resolvedMode = mode;\n    if (!resolvedMode) resolvedMode = \"then\";\n\n    if (resolvedMode === \"then\") {\n      var nextTickFailure = function () {\n        nextTick(onFailure);\n      }; // Eventual finally needs to be attached to non rejected promise\n      // (so we not force propagation of unhandled rejection)\n\n\n      promise = promise.then(function (result) {\n        nextTick(onSuccess.bind(this, result));\n      }, nextTickFailure); // If `finally` is a function we attach to it to remove cancelled promises.\n\n      if (typeof promise.finally === \"function\") {\n        promise.finally(nextTickFailure);\n      }\n    } else if (resolvedMode === \"done\") {\n      // Not recommended, as it may mute any eventual \"Unhandled error\" events\n      if (typeof promise.done !== \"function\") {\n        throw new Error(\"Memoizee error: Retrieved promise does not implement 'done' \" + \"in 'done' mode\");\n      }\n\n      promise.done(onSuccess, onFailure);\n    } else if (resolvedMode === \"done:finally\") {\n      // The only mode with no side effects assuming library does not throw unconditionally\n      // for rejected promises.\n      if (typeof promise.done !== \"function\") {\n        throw new Error(\"Memoizee error: Retrieved promise does not implement 'done' \" + \"in 'done:finally' mode\");\n      }\n\n      if (typeof promise.finally !== \"function\") {\n        throw new Error(\"Memoizee error: Retrieved promise does not implement 'finally' \" + \"in 'done:finally' mode\");\n      }\n\n      promise.done(onSuccess);\n      promise.finally(onFailure);\n    }\n  }); // From cache (sync)\n\n  conf.on(\"get\", function (id, args, context) {\n    var promise;\n\n    if (waiting[id]) {\n      ++waiting[id]; // Still waiting\n\n      return;\n    }\n\n    promise = promises[id];\n\n    var emit = function () {\n      conf.emit(\"getasync\", id, args, context);\n    };\n\n    if (isPromise(promise)) {\n      if (typeof promise.done === \"function\") promise.done(emit);else {\n        promise.then(function () {\n          nextTick(emit);\n        });\n      }\n    } else {\n      emit();\n    }\n  }); // On delete\n\n  conf.on(\"delete\", function (id) {\n    delete promises[id];\n\n    if (waiting[id]) {\n      delete waiting[id];\n      return; // Not yet resolved\n    }\n\n    if (!hasOwnProperty.call(cache, id)) return;\n    var result = cache[id];\n    delete cache[id];\n    conf.emit(\"deleteasync\", id, [result]);\n  }); // On clear\n\n  conf.on(\"clear\", function () {\n    var oldCache = cache;\n    cache = create(null);\n    waiting = create(null);\n    promises = create(null);\n    conf.emit(\"clearasync\", objectMap(oldCache, function (data) {\n      return [data];\n    }));\n  });\n};","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/memoizee/ext/promise.js"],"names":["objectMap","require","primitiveSet","ensureString","toShortString","isPromise","nextTick","create","Object","supportedModes","promise","mode","conf","waiting","cache","promises","TypeError","on","id","ignore","isFailed","emit","onSuccess","result","count","Error","onFailure","delete","resolvedMode","nextTickFailure","then","bind","finally","done","args","context","hasOwnProperty","call","oldCache","data"],"mappings":"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","sourcesContent":["/* eslint max-statements: 0 */\n\n// Support for functions returning promise\n\n\"use strict\";\n\nvar objectMap     = require(\"es5-ext/object/map\")\n  , primitiveSet  = require(\"es5-ext/object/primitive-set\")\n  , ensureString  = require(\"es5-ext/object/validate-stringifiable-value\")\n  , toShortString = require(\"es5-ext/to-short-string-representation\")\n  , isPromise     = require(\"is-promise\")\n  , nextTick      = require(\"next-tick\");\n\nvar create = Object.create\n  , supportedModes = primitiveSet(\"then\", \"then:finally\", \"done\", \"done:finally\");\n\nrequire(\"../lib/registered-extensions\").promise = function (mode, conf) {\n\tvar waiting = create(null), cache = create(null), promises = create(null);\n\n\tif (mode === true) {\n\t\tmode = null;\n\t} else {\n\t\tmode = ensureString(mode);\n\t\tif (!supportedModes[mode]) {\n\t\t\tthrow new TypeError(\"'\" + toShortString(mode) + \"' is not valid promise mode\");\n\t\t}\n\t}\n\n\t// After not from cache call\n\tconf.on(\"set\", function (id, ignore, promise) {\n\t\tvar isFailed = false;\n\n\t\tif (!isPromise(promise)) {\n\t\t\t// Non promise result\n\t\t\tcache[id] = promise;\n\t\t\tconf.emit(\"setasync\", id, 1);\n\t\t\treturn;\n\t\t}\n\t\twaiting[id] = 1;\n\t\tpromises[id] = promise;\n\t\tvar onSuccess = function (result) {\n\t\t\tvar count = waiting[id];\n\t\t\tif (isFailed) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Detected unordered then|done & finally resolution, which \" +\n\t\t\t\t\t\t\"in turn makes proper detection of success/failure impossible (when in \" +\n\t\t\t\t\t\t\"'done:finally' mode)\\n\" +\n\t\t\t\t\t\t\"Consider to rely on 'then' or 'done' mode instead.\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!count) return; // Deleted from cache before resolved\n\t\t\tdelete waiting[id];\n\t\t\tcache[id] = result;\n\t\t\tconf.emit(\"setasync\", id, count);\n\t\t};\n\t\tvar onFailure = function () {\n\t\t\tisFailed = true;\n\t\t\tif (!waiting[id]) return; // Deleted from cache (or succeed in case of finally)\n\t\t\tdelete waiting[id];\n\t\t\tdelete promises[id];\n\t\t\tconf.delete(id);\n\t\t};\n\n\t\tvar resolvedMode = mode;\n\t\tif (!resolvedMode) resolvedMode = \"then\";\n\n\t\tif (resolvedMode === \"then\") {\n\t\t\tvar nextTickFailure = function () { nextTick(onFailure); };\n\t\t\t// Eventual finally needs to be attached to non rejected promise\n\t\t\t// (so we not force propagation of unhandled rejection)\n\t\t\tpromise = promise.then(function (result) {\n\t\t\t\tnextTick(onSuccess.bind(this, result));\n\t\t\t}, nextTickFailure);\n\t\t\t// If `finally` is a function we attach to it to remove cancelled promises.\n\t\t\tif (typeof promise.finally === \"function\") {\n\t\t\t\tpromise.finally(nextTickFailure);\n\t\t\t}\n\t\t} else if (resolvedMode === \"done\") {\n\t\t\t// Not recommended, as it may mute any eventual \"Unhandled error\" events\n\t\t\tif (typeof promise.done !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'done' \" +\n\t\t\t\t\t\t\"in 'done' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tpromise.done(onSuccess, onFailure);\n\t\t} else if (resolvedMode === \"done:finally\") {\n\t\t\t// The only mode with no side effects assuming library does not throw unconditionally\n\t\t\t// for rejected promises.\n\t\t\tif (typeof promise.done !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'done' \" +\n\t\t\t\t\t\t\"in 'done:finally' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (typeof promise.finally !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'finally' \" +\n\t\t\t\t\t\t\"in 'done:finally' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tpromise.done(onSuccess);\n\t\t\tpromise.finally(onFailure);\n\t\t}\n\t});\n\n\t// From cache (sync)\n\tconf.on(\"get\", function (id, args, context) {\n\t\tvar promise;\n\t\tif (waiting[id]) {\n\t\t\t++waiting[id]; // Still waiting\n\t\t\treturn;\n\t\t}\n\t\tpromise = promises[id];\n\t\tvar emit = function () { conf.emit(\"getasync\", id, args, context); };\n\t\tif (isPromise(promise)) {\n\t\t\tif (typeof promise.done === \"function\") promise.done(emit);\n\t\t\telse {\n\t\t\t\tpromise.then(function () { nextTick(emit); });\n\t\t\t}\n\t\t} else {\n\t\t\temit();\n\t\t}\n\t});\n\n\t// On delete\n\tconf.on(\"delete\", function (id) {\n\t\tdelete promises[id];\n\t\tif (waiting[id]) {\n\t\t\tdelete waiting[id];\n\t\t\treturn; // Not yet resolved\n\t\t}\n\t\tif (!hasOwnProperty.call(cache, id)) return;\n\t\tvar result = cache[id];\n\t\tdelete cache[id];\n\t\tconf.emit(\"deleteasync\", id, [result]);\n\t});\n\n\t// On clear\n\tconf.on(\"clear\", function () {\n\t\tvar oldCache = cache;\n\t\tcache = create(null);\n\t\twaiting = create(null);\n\t\tpromises = create(null);\n\t\tconf.emit(\"clearasync\", objectMap(oldCache, function (data) { return [data]; }));\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}