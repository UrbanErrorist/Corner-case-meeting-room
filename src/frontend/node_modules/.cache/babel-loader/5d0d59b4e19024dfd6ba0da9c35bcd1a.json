{"ast":null,"code":"// Query String Utilities\n'use strict';\n\nvar QueryString = exports;\n\nvar Buffer = require('buffer').Buffer; // a safe fast alternative to decodeURIComponent\n\n\nQueryString.unescapeBuffer = function (s, decodeSpaces) {\n  var out = new Buffer(s.length);\n  var state = 0;\n  var n, m, hexchar;\n\n  for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++) {\n    var c = inIndex < s.length ? s.charCodeAt(inIndex) : NaN;\n\n    switch (state) {\n      case 0:\n        // Any character\n        switch (c) {\n          case 37:\n            // '%'\n            n = 0;\n            m = 0;\n            state = 1;\n            break;\n\n          case 43:\n            // '+'\n            if (decodeSpaces) c = 32;\n          // ' '\n          // falls through\n\n          default:\n            out[outIndex++] = c;\n            break;\n        }\n\n        break;\n\n      case 1:\n        // First hex digit\n        hexchar = c;\n\n        if (c >= 48\n        /*0*/\n        && c <= 57\n        /*9*/\n        ) {\n            n = c - 48\n            /*0*/\n            ;\n          } else if (c >= 65\n        /*A*/\n        && c <= 70\n        /*F*/\n        ) {\n            n = c - 65\n            /*A*/\n            + 10;\n          } else if (c >= 97\n        /*a*/\n        && c <= 102\n        /*f*/\n        ) {\n            n = c - 97\n            /*a*/\n            + 10;\n          } else {\n          out[outIndex++] = 37\n          /*%*/\n          ;\n          out[outIndex++] = c;\n          state = 0;\n          break;\n        }\n\n        state = 2;\n        break;\n\n      case 2:\n        // Second hex digit\n        state = 0;\n\n        if (c >= 48\n        /*0*/\n        && c <= 57\n        /*9*/\n        ) {\n            m = c - 48\n            /*0*/\n            ;\n          } else if (c >= 65\n        /*A*/\n        && c <= 70\n        /*F*/\n        ) {\n            m = c - 65\n            /*A*/\n            + 10;\n          } else if (c >= 97\n        /*a*/\n        && c <= 102\n        /*f*/\n        ) {\n            m = c - 97\n            /*a*/\n            + 10;\n          } else {\n          out[outIndex++] = 37\n          /*%*/\n          ;\n          out[outIndex++] = hexchar;\n          out[outIndex++] = c;\n          break;\n        }\n\n        out[outIndex++] = 16 * n + m;\n        break;\n    }\n  } // TODO support returning arbitrary buffers.\n\n\n  return out.slice(0, outIndex - 1);\n};\n\nfunction qsUnescape(s, decodeSpaces) {\n  try {\n    return decodeURIComponent(s);\n  } catch (e) {\n    return QueryString.unescapeBuffer(s, decodeSpaces).toString();\n  }\n}\n\nQueryString.unescape = qsUnescape;\nvar hexTable = new Array(256);\n\nfor (var i = 0; i < 256; ++i) hexTable[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n\nQueryString.escape = function (str) {\n  // replaces encodeURIComponent\n  // http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3.4\n  if (typeof str !== 'string') str += '';\n  var out = '';\n  var lastPos = 0;\n\n  for (var i = 0; i < str.length; ++i) {\n    var c = str.charCodeAt(i); // These characters do not need escaping (in order):\n    // ! - . _ ~\n    // ' ( ) *\n    // digits\n    // alpha (uppercase)\n    // alpha (lowercase)\n\n    if (c === 0x21 || c === 0x2D || c === 0x2E || c === 0x5F || c === 0x7E || c >= 0x27 && c <= 0x2A || c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A) {\n      continue;\n    }\n\n    if (i - lastPos > 0) out += str.slice(lastPos, i); // Other ASCII characters\n\n    if (c < 0x80) {\n      lastPos = i + 1;\n      out += hexTable[c];\n      continue;\n    } // Multi-byte characters ...\n\n\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F];\n      continue;\n    }\n\n    if (c < 0xD800 || c >= 0xE000) {\n      lastPos = i + 1;\n      out += hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];\n      continue;\n    } // Surrogate pair\n\n\n    ++i;\n    var c2;\n    if (i < str.length) c2 = str.charCodeAt(i) & 0x3FF;else throw new URIError('URI malformed');\n    lastPos = i + 1;\n    c = 0x10000 + ((c & 0x3FF) << 10 | c2);\n    out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];\n  }\n\n  if (lastPos === 0) return str;\n  if (lastPos < str.length) return out + str.slice(lastPos);\n  return out;\n};\n\nvar stringifyPrimitive = function (v) {\n  if (typeof v === 'string') return v;\n  if (typeof v === 'number' && isFinite(v)) return '' + v;\n  if (typeof v === 'boolean') return v ? 'true' : 'false';\n  return '';\n};\n\nQueryString.stringify = QueryString.encode = function (obj, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var encode = QueryString.escape;\n\n  if (options && typeof options.encodeURIComponent === 'function') {\n    encode = options.encodeURIComponent;\n  }\n\n  if (obj !== null && typeof obj === 'object') {\n    var keys = Object.keys(obj);\n    var len = keys.length;\n    var flast = len - 1;\n    var fields = '';\n\n    for (var i = 0; i < len; ++i) {\n      var k = keys[i];\n      var v = obj[k];\n      var ks = encode(stringifyPrimitive(k)) + eq;\n\n      if (Array.isArray(v)) {\n        var vlen = v.length;\n        var vlast = vlen - 1;\n\n        for (var j = 0; j < vlen; ++j) {\n          fields += ks + encode(stringifyPrimitive(v[j]));\n          if (j < vlast) fields += sep;\n        }\n\n        if (vlen && i < flast) fields += sep;\n      } else {\n        fields += ks + encode(stringifyPrimitive(v));\n        if (i < flast) fields += sep;\n      }\n    }\n\n    return fields;\n  }\n\n  return '';\n}; // Parse a key/val string.\n\n\nQueryString.parse = QueryString.decode = function (qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  if (typeof sep !== 'string') sep += '';\n  var eqLen = eq.length;\n  var sepLen = sep.length;\n  var maxKeys = 1000;\n\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var pairs = Infinity;\n  if (maxKeys > 0) pairs = maxKeys;\n  var decode = QueryString.unescape;\n\n  if (options && typeof options.decodeURIComponent === 'function') {\n    decode = options.decodeURIComponent;\n  }\n\n  var customDecode = decode !== qsUnescape;\n  var keys = [];\n  var lastPos = 0;\n  var sepIdx = 0;\n  var eqIdx = 0;\n  var key = '';\n  var value = '';\n  var keyEncoded = customDecode;\n  var valEncoded = customDecode;\n  var encodeCheck = 0;\n\n  for (var i = 0; i < qs.length; ++i) {\n    var code = qs.charCodeAt(i); // Try matching key/value pair separator (e.g. '&')\n\n    if (code === sep.charCodeAt(sepIdx)) {\n      if (++sepIdx === sepLen) {\n        // Key/value pair separator match!\n        var end = i - sepIdx + 1;\n\n        if (eqIdx < eqLen) {\n          // If we didn't find the key/value separator, treat the substring as\n          // part of the key instead of the value\n          if (lastPos < end) key += qs.slice(lastPos, end);\n        } else if (lastPos < end) value += qs.slice(lastPos, end);\n\n        if (keyEncoded) key = decodeStr(key, decode);\n        if (valEncoded) value = decodeStr(value, decode); // Use a key array lookup instead of using hasOwnProperty(), which is\n        // slower\n\n        if (keys.indexOf(key) === -1) {\n          obj[key] = value;\n          keys[keys.length] = key;\n        } else {\n          var curValue = obj[key]; // `instanceof Array` is used instead of Array.isArray() because it\n          // is ~15-20% faster with v8 4.7 and is safe to use because we are\n          // using it with values being created within this function\n\n          if (curValue instanceof Array) curValue[curValue.length] = value;else obj[key] = [curValue, value];\n        }\n\n        if (--pairs === 0) break;\n        keyEncoded = valEncoded = customDecode;\n        encodeCheck = 0;\n        key = value = '';\n        lastPos = i + 1;\n        sepIdx = eqIdx = 0;\n      }\n\n      continue;\n    } else {\n      sepIdx = 0;\n\n      if (!valEncoded) {\n        // Try to match an (valid) encoded byte (once) to minimize unnecessary\n        // calls to string decoding functions\n        if (code === 37\n        /*%*/\n        ) {\n            encodeCheck = 1;\n          } else if (encodeCheck > 0 && (code >= 48\n        /*0*/\n        && code <= 57\n        /*9*/\n        || code >= 65\n        /*A*/\n        && code <= 70\n        /*Z*/\n        || code >= 97\n        /*a*/\n        && code <= 102\n        /*z*/\n        )) {\n          if (++encodeCheck === 3) valEncoded = true;\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    } // Try matching key/value separator (e.g. '=') if we haven't already\n\n\n    if (eqIdx < eqLen) {\n      if (code === eq.charCodeAt(eqIdx)) {\n        if (++eqIdx === eqLen) {\n          // Key/value separator match!\n          var end = i - eqIdx + 1;\n          if (lastPos < end) key += qs.slice(lastPos, end);\n          encodeCheck = 0;\n          lastPos = i + 1;\n        }\n\n        continue;\n      } else {\n        eqIdx = 0;\n\n        if (!keyEncoded) {\n          // Try to match an (valid) encoded byte once to minimize unnecessary\n          // calls to string decoding functions\n          if (code === 37\n          /*%*/\n          ) {\n              encodeCheck = 1;\n            } else if (encodeCheck > 0 && (code >= 48\n          /*0*/\n          && code <= 57\n          /*9*/\n          || code >= 65\n          /*A*/\n          && code <= 70\n          /*Z*/\n          || code >= 97\n          /*a*/\n          && code <= 102\n          /*z*/\n          )) {\n            if (++encodeCheck === 3) keyEncoded = true;\n          } else {\n            encodeCheck = 0;\n          }\n        }\n      }\n    }\n\n    if (code === 43\n    /*+*/\n    ) {\n        if (eqIdx < eqLen) {\n          if (i - lastPos > 0) key += qs.slice(lastPos, i);\n          key += '%20';\n          keyEncoded = true;\n        } else {\n          if (i - lastPos > 0) value += qs.slice(lastPos, i);\n          value += '%20';\n          valEncoded = true;\n        }\n\n        lastPos = i + 1;\n      }\n  } // Check if we have leftover key or value data\n\n\n  if (pairs > 0 && (lastPos < qs.length || eqIdx > 0)) {\n    if (lastPos < qs.length) {\n      if (eqIdx < eqLen) key += qs.slice(lastPos);else if (sepIdx < sepLen) value += qs.slice(lastPos);\n    }\n\n    if (keyEncoded) key = decodeStr(key, decode);\n    if (valEncoded) value = decodeStr(value, decode); // Use a key array lookup instead of using hasOwnProperty(), which is\n    // slower\n\n    if (keys.indexOf(key) === -1) {\n      obj[key] = value;\n      keys[keys.length] = key;\n    } else {\n      var curValue = obj[key]; // `instanceof Array` is used instead of Array.isArray() because it\n      // is ~15-20% faster with v8 4.7 and is safe to use because we are\n      // using it with values being created within this function\n\n      if (curValue instanceof Array) curValue[curValue.length] = value;else obj[key] = [curValue, value];\n    }\n  }\n\n  return obj;\n}; // v8 does not optimize functions with try-catch blocks, so we isolate them here\n// to minimize the damage\n\n\nfunction decodeStr(s, decoder) {\n  try {\n    return decoder(s);\n  } catch (e) {\n    return QueryString.unescape(s, true);\n  }\n}","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/querystring-browser/querystring.js"],"names":["QueryString","exports","Buffer","require","unescapeBuffer","s","decodeSpaces","out","length","state","n","m","hexchar","inIndex","outIndex","c","charCodeAt","NaN","slice","qsUnescape","decodeURIComponent","e","toString","unescape","hexTable","Array","i","toUpperCase","escape","str","lastPos","c2","URIError","stringifyPrimitive","v","isFinite","stringify","encode","obj","sep","eq","options","encodeURIComponent","keys","Object","len","flast","fields","k","ks","isArray","vlen","vlast","j","parse","decode","qs","eqLen","sepLen","maxKeys","pairs","Infinity","customDecode","sepIdx","eqIdx","key","value","keyEncoded","valEncoded","encodeCheck","code","end","decodeStr","indexOf","curValue","decoder"],"mappings":"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","sourcesContent":["// Query String Utilities\n\n'use strict';\n\nvar QueryString = exports;\nvar Buffer = require('buffer').Buffer;\n\n\n// a safe fast alternative to decodeURIComponent\nQueryString.unescapeBuffer = function(s, decodeSpaces) {\n  var out = new Buffer(s.length);\n  var state = 0;\n  var n, m, hexchar;\n\n  for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++) {\n    var c = inIndex < s.length ? s.charCodeAt(inIndex) : NaN;\n    switch (state) {\n      case 0: // Any character\n        switch (c) {\n          case 37: // '%'\n            n = 0;\n            m = 0;\n            state = 1;\n            break;\n          case 43: // '+'\n            if (decodeSpaces)\n              c = 32; // ' '\n            // falls through\n          default:\n            out[outIndex++] = c;\n            break;\n        }\n        break;\n\n      case 1: // First hex digit\n        hexchar = c;\n        if (c >= 48/*0*/ && c <= 57/*9*/) {\n          n = c - 48/*0*/;\n        } else if (c >= 65/*A*/ && c <= 70/*F*/) {\n          n = c - 65/*A*/ + 10;\n        } else if (c >= 97/*a*/ && c <= 102/*f*/) {\n          n = c - 97/*a*/ + 10;\n        } else {\n          out[outIndex++] = 37/*%*/;\n          out[outIndex++] = c;\n          state = 0;\n          break;\n        }\n        state = 2;\n        break;\n\n      case 2: // Second hex digit\n        state = 0;\n        if (c >= 48/*0*/ && c <= 57/*9*/) {\n          m = c -  48/*0*/;\n        } else if (c >= 65/*A*/ && c <= 70/*F*/) {\n          m = c - 65/*A*/ + 10;\n        } else if (c >= 97/*a*/ && c <= 102/*f*/) {\n          m = c - 97/*a*/ + 10;\n        } else {\n          out[outIndex++] = 37/*%*/;\n          out[outIndex++] = hexchar;\n          out[outIndex++] = c;\n          break;\n        }\n        out[outIndex++] = 16 * n + m;\n        break;\n    }\n  }\n\n  // TODO support returning arbitrary buffers.\n\n  return out.slice(0, outIndex - 1);\n};\n\n\nfunction qsUnescape(s, decodeSpaces) {\n  try {\n    return decodeURIComponent(s);\n  } catch (e) {\n    return QueryString.unescapeBuffer(s, decodeSpaces).toString();\n  }\n}\nQueryString.unescape = qsUnescape;\n\n\nvar hexTable = new Array(256);\nfor (var i = 0; i < 256; ++i)\n  hexTable[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\nQueryString.escape = function(str) {\n  // replaces encodeURIComponent\n  // http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3.4\n  if (typeof str !== 'string')\n    str += '';\n  var out = '';\n  var lastPos = 0;\n\n  for (var i = 0; i < str.length; ++i) {\n    var c = str.charCodeAt(i);\n\n    // These characters do not need escaping (in order):\n    // ! - . _ ~\n    // ' ( ) *\n    // digits\n    // alpha (uppercase)\n    // alpha (lowercase)\n    if (c === 0x21 || c === 0x2D || c === 0x2E || c === 0x5F || c === 0x7E ||\n        (c >= 0x27 && c <= 0x2A) ||\n        (c >= 0x30 && c <= 0x39) ||\n        (c >= 0x41 && c <= 0x5A) ||\n        (c >= 0x61 && c <= 0x7A)) {\n      continue;\n    }\n\n    if (i - lastPos > 0)\n      out += str.slice(lastPos, i);\n\n    // Other ASCII characters\n    if (c < 0x80) {\n      lastPos = i + 1;\n      out += hexTable[c];\n      continue;\n    }\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    if (c < 0xD800 || c >= 0xE000) {\n      lastPos = i + 1;\n      out += hexTable[0xE0 | (c >> 12)] +\n             hexTable[0x80 | ((c >> 6) & 0x3F)] +\n             hexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n    var c2;\n    if (i < str.length)\n      c2 = str.charCodeAt(i) & 0x3FF;\n    else\n      throw new URIError('URI malformed');\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3FF) << 10) | c2);\n    out += hexTable[0xF0 | (c >> 18)] +\n           hexTable[0x80 | ((c >> 12) & 0x3F)] +\n           hexTable[0x80 | ((c >> 6) & 0x3F)] +\n           hexTable[0x80 | (c & 0x3F)];\n  }\n  if (lastPos === 0)\n    return str;\n  if (lastPos < str.length)\n    return out + str.slice(lastPos);\n  return out;\n};\n\nvar stringifyPrimitive = function(v) {\n  if (typeof v === 'string')\n    return v;\n  if (typeof v === 'number' && isFinite(v))\n    return '' + v;\n  if (typeof v === 'boolean')\n    return v ? 'true' : 'false';\n  return '';\n};\n\n\nQueryString.stringify = QueryString.encode = function(obj, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n\n  var encode = QueryString.escape;\n  if (options && typeof options.encodeURIComponent === 'function') {\n    encode = options.encodeURIComponent;\n  }\n\n  if (obj !== null && typeof obj === 'object') {\n    var keys = Object.keys(obj);\n    var len = keys.length;\n    var flast = len - 1;\n    var fields = '';\n    for (var i = 0; i < len; ++i) {\n      var k = keys[i];\n      var v = obj[k];\n      var ks = encode(stringifyPrimitive(k)) + eq;\n\n      if (Array.isArray(v)) {\n        var vlen = v.length;\n        var vlast = vlen - 1;\n        for (var j = 0; j < vlen; ++j) {\n          fields += ks + encode(stringifyPrimitive(v[j]));\n          if (j < vlast)\n            fields += sep;\n        }\n        if (vlen && i < flast)\n          fields += sep;\n      } else {\n        fields += ks + encode(stringifyPrimitive(v));\n        if (i < flast)\n          fields += sep;\n      }\n    }\n    return fields;\n  }\n  return '';\n};\n\n// Parse a key/val string.\nQueryString.parse = QueryString.decode = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  if (typeof sep !== 'string')\n    sep += '';\n\n  var eqLen = eq.length;\n  var sepLen = sep.length;\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var pairs = Infinity;\n  if (maxKeys > 0)\n    pairs = maxKeys;\n\n  var decode = QueryString.unescape;\n  if (options && typeof options.decodeURIComponent === 'function') {\n    decode = options.decodeURIComponent;\n  }\n  var customDecode = (decode !== qsUnescape);\n\n  var keys = [];\n  var lastPos = 0;\n  var sepIdx = 0;\n  var eqIdx = 0;\n  var key = '';\n  var value = '';\n  var keyEncoded = customDecode;\n  var valEncoded = customDecode;\n  var encodeCheck = 0;\n  for (var i = 0; i < qs.length; ++i) {\n    var code = qs.charCodeAt(i);\n\n    // Try matching key/value pair separator (e.g. '&')\n    if (code === sep.charCodeAt(sepIdx)) {\n      if (++sepIdx === sepLen) {\n        // Key/value pair separator match!\n        var end = i - sepIdx + 1;\n        if (eqIdx < eqLen) {\n          // If we didn't find the key/value separator, treat the substring as\n          // part of the key instead of the value\n          if (lastPos < end)\n            key += qs.slice(lastPos, end);\n        } else if (lastPos < end)\n          value += qs.slice(lastPos, end);\n        if (keyEncoded)\n          key = decodeStr(key, decode);\n        if (valEncoded)\n          value = decodeStr(value, decode);\n        // Use a key array lookup instead of using hasOwnProperty(), which is\n        // slower\n        if (keys.indexOf(key) === -1) {\n          obj[key] = value;\n          keys[keys.length] = key;\n        } else {\n          var curValue = obj[key];\n          // `instanceof Array` is used instead of Array.isArray() because it\n          // is ~15-20% faster with v8 4.7 and is safe to use because we are\n          // using it with values being created within this function\n          if (curValue instanceof Array)\n            curValue[curValue.length] = value;\n          else\n            obj[key] = [curValue, value];\n        }\n        if (--pairs === 0)\n          break;\n        keyEncoded = valEncoded = customDecode;\n        encodeCheck = 0;\n        key = value = '';\n        lastPos = i + 1;\n        sepIdx = eqIdx = 0;\n      }\n      continue;\n    } else {\n      sepIdx = 0;\n      if (!valEncoded) {\n        // Try to match an (valid) encoded byte (once) to minimize unnecessary\n        // calls to string decoding functions\n        if (code === 37/*%*/) {\n          encodeCheck = 1;\n        } else if (encodeCheck > 0 &&\n                   ((code >= 48/*0*/ && code <= 57/*9*/) ||\n                    (code >= 65/*A*/ && code <= 70/*Z*/) ||\n                    (code >= 97/*a*/ && code <= 102/*z*/))) {\n          if (++encodeCheck === 3)\n            valEncoded = true;\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (eqIdx < eqLen) {\n      if (code === eq.charCodeAt(eqIdx)) {\n        if (++eqIdx === eqLen) {\n          // Key/value separator match!\n          var end = i - eqIdx + 1;\n          if (lastPos < end)\n            key += qs.slice(lastPos, end);\n          encodeCheck = 0;\n          lastPos = i + 1;\n        }\n        continue;\n      } else {\n        eqIdx = 0;\n        if (!keyEncoded) {\n          // Try to match an (valid) encoded byte once to minimize unnecessary\n          // calls to string decoding functions\n          if (code === 37/*%*/) {\n            encodeCheck = 1;\n          } else if (encodeCheck > 0 &&\n                     ((code >= 48/*0*/ && code <= 57/*9*/) ||\n                      (code >= 65/*A*/ && code <= 70/*Z*/) ||\n                      (code >= 97/*a*/ && code <= 102/*z*/))) {\n            if (++encodeCheck === 3)\n              keyEncoded = true;\n          } else {\n            encodeCheck = 0;\n          }\n        }\n      }\n    }\n\n    if (code === 43/*+*/) {\n      if (eqIdx < eqLen) {\n        if (i - lastPos > 0)\n          key += qs.slice(lastPos, i);\n        key += '%20';\n        keyEncoded = true;\n      } else {\n        if (i - lastPos > 0)\n          value += qs.slice(lastPos, i);\n        value += '%20';\n        valEncoded = true;\n      }\n      lastPos = i + 1;\n    }\n  }\n\n  // Check if we have leftover key or value data\n  if (pairs > 0 && (lastPos < qs.length || eqIdx > 0)) {\n    if (lastPos < qs.length) {\n      if (eqIdx < eqLen)\n        key += qs.slice(lastPos);\n      else if (sepIdx < sepLen)\n        value += qs.slice(lastPos);\n    }\n    if (keyEncoded)\n      key = decodeStr(key, decode);\n    if (valEncoded)\n      value = decodeStr(value, decode);\n    // Use a key array lookup instead of using hasOwnProperty(), which is\n    // slower\n    if (keys.indexOf(key) === -1) {\n      obj[key] = value;\n      keys[keys.length] = key;\n    } else {\n      var curValue = obj[key];\n      // `instanceof Array` is used instead of Array.isArray() because it\n      // is ~15-20% faster with v8 4.7 and is safe to use because we are\n      // using it with values being created within this function\n      if (curValue instanceof Array)\n        curValue[curValue.length] = value;\n      else\n        obj[key] = [curValue, value];\n    }\n  }\n\n  return obj;\n};\n\n\n// v8 does not optimize functions with try-catch blocks, so we isolate them here\n// to minimize the damage\nfunction decodeStr(s, decoder) {\n  try {\n    return decoder(s);\n  } catch (e) {\n    return QueryString.unescape(s, true);\n  }\n}"]},"metadata":{},"sourceType":"script"}