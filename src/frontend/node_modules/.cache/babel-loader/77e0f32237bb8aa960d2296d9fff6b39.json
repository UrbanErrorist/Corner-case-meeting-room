{"ast":null,"code":"'use strict';\n\nvar StateInline = require('../rules_inline/state_inline');\n\nvar parseLinkLabel = require('../helpers/parse_link_label');\n\nvar parseLinkDestination = require('../helpers/parse_link_destination');\n\nvar parseLinkTitle = require('../helpers/parse_link_title');\n\nvar normalizeReference = require('../helpers/normalize_reference');\n\nfunction parseReference(str, parser, options, env) {\n  var state, labelEnd, pos, max, code, start, href, title, label;\n\n  if (str.charCodeAt(0) !== 0x5B\n  /* [ */\n  ) {\n      return -1;\n    }\n\n  if (str.indexOf(']:') === -1) {\n    return -1;\n  }\n\n  state = new StateInline(str, parser, options, env, []);\n  labelEnd = parseLinkLabel(state, 0);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A\n  /* : */\n  ) {\n      return -1;\n    }\n\n  max = state.posMax; // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n\n    if (code !== 0x20 && code !== 0x0A) {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n\n\n  if (!parseLinkDestination(state, pos)) {\n    return -1;\n  }\n\n  href = state.linkContent;\n  pos = state.pos; // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n\n  start = pos;\n\n  for (pos = pos + 1; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n\n    if (code !== 0x20 && code !== 0x0A) {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n\n\n  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n    title = state.linkContent;\n    pos = state.pos;\n  } else {\n    title = '';\n    pos = start;\n  } // ensure that the end of the line is empty\n\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x20\n  /* space */\n  ) {\n    pos++;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) {\n    return -1;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n\n  if (typeof env.references[label] === 'undefined') {\n    env.references[label] = {\n      title: title,\n      href: href\n    };\n  }\n\n  return pos;\n}\n\nmodule.exports = function references(state) {\n  var tokens = state.tokens,\n      i,\n      l,\n      content,\n      pos;\n  state.env.references = state.env.references || {};\n\n  if (state.inlineMode) {\n    return;\n  } // Scan definitions in paragraph inlines\n\n\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i].type === 'inline' && tokens[i - 1].type === 'paragraph_open' && tokens[i + 1].type === 'paragraph_close') {\n      content = tokens[i].content;\n\n      while (content.length) {\n        pos = parseReference(content, state.inline, state.options, state.env);\n\n        if (pos < 0) {\n          break;\n        }\n\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/remarkable/lib/rules_core/references.js"],"names":["StateInline","require","parseLinkLabel","parseLinkDestination","parseLinkTitle","normalizeReference","parseReference","str","parser","options","env","state","labelEnd","pos","max","code","start","href","title","label","charCodeAt","indexOf","posMax","src","linkContent","slice","references","module","exports","tokens","i","l","content","inlineMode","length","type","inline","trim","tight"],"mappings":"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","sourcesContent":["'use strict';\n\n\nvar StateInline          = require('../rules_inline/state_inline');\nvar parseLinkLabel       = require('../helpers/parse_link_label');\nvar parseLinkDestination = require('../helpers/parse_link_destination');\nvar parseLinkTitle       = require('../helpers/parse_link_title');\nvar normalizeReference   = require('../helpers/normalize_reference');\n\n\nfunction parseReference(str, parser, options, env) {\n  var state, labelEnd, pos, max, code, start, href, title, label;\n\n  if (str.charCodeAt(0) !== 0x5B/* [ */) { return -1; }\n\n  if (str.indexOf(']:') === -1) { return -1; }\n\n  state = new StateInline(str, parser, options, env, []);\n  labelEnd = parseLinkLabel(state, 0);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n  max = state.posMax;\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) { break; }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  if (!parseLinkDestination(state, pos)) { return -1; }\n  href = state.linkContent;\n  pos = state.pos;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (pos = pos + 1; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) { break; }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n    title = state.linkContent;\n    pos = state.pos;\n  } else {\n    title = '';\n    pos = start;\n  }\n\n  // ensure that the end of the line is empty\n  while (pos < max && state.src.charCodeAt(pos) === 0x20/* space */) { pos++; }\n  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) { return -1; }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (typeof env.references[label] === 'undefined') {\n    env.references[label] = { title: title, href: href };\n  }\n\n  return pos;\n}\n\n\nmodule.exports = function references(state) {\n  var tokens = state.tokens, i, l, content, pos;\n\n  state.env.references = state.env.references || {};\n\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Scan definitions in paragraph inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i].type === 'inline' &&\n        tokens[i - 1].type === 'paragraph_open' &&\n        tokens[i + 1].type === 'paragraph_close') {\n\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseReference(content, state.inline, state.options, state.env);\n        if (pos < 0) { break; }\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}