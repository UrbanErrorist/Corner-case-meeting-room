{"ast":null,"code":"'use strict';\n/**\n * Local dependencies\n */\n\nvar Ruler = require('./ruler');\n\nvar StateBlock = require('./rules_block/state_block');\n/**\n * Parser rules\n */\n\n\nvar _rules = [['code', require('./rules_block/code')], ['fences', require('./rules_block/fences'), ['paragraph', 'blockquote', 'list']], ['blockquote', require('./rules_block/blockquote'), ['paragraph', 'blockquote', 'list']], ['hr', require('./rules_block/hr'), ['paragraph', 'blockquote', 'list']], ['list', require('./rules_block/list'), ['paragraph', 'blockquote']], ['footnote', require('./rules_block/footnote'), ['paragraph']], ['heading', require('./rules_block/heading'), ['paragraph', 'blockquote']], ['lheading', require('./rules_block/lheading')], ['htmlblock', require('./rules_block/htmlblock'), ['paragraph', 'blockquote']], ['table', require('./rules_block/table'), ['paragraph']], ['deflist', require('./rules_block/deflist'), ['paragraph']], ['paragraph', require('./rules_block/paragraph')]];\n/**\n * Block Parser class\n *\n * @api private\n */\n\nfunction ParserBlock() {\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], {\n      alt: (_rules[i][2] || []).slice()\n    });\n  }\n}\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n * @param  {Number} `startLine`\n * @param  {Number} `endLine`\n * @api private\n */\n\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var line = startLine;\n  var hasEmptyLines = false;\n  var ok, i;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n\n    if (line >= endLine) {\n      break;\n    } // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n\n\n    if (state.tShift[line] < state.blkIndent) {\n      break;\n    } // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n\n      if (ok) {\n        break;\n      }\n    } // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n\n\n    state.tight = !hasEmptyLines; // paragraph might \"eat\" one newline after it in nested lists\n\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++; // two empty lines should stop the parser in list mode\n\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) {\n        break;\n      }\n\n      state.line = line;\n    }\n  }\n};\n\nvar TABS_SCAN_RE = /[\\n\\t]/g;\nvar NEWLINES_RE = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar SPACES_RE = /\\u00a0/g;\n/**\n * Tokenize the given `str`.\n *\n * @param  {String} `str` Source string\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserBlock.prototype.parse = function (str, options, env, outTokens) {\n  var state,\n      lineStart = 0,\n      lastTabPos = 0;\n\n  if (!str) {\n    return [];\n  } // Normalize spaces\n\n\n  str = str.replace(SPACES_RE, ' '); // Normalize newlines\n\n  str = str.replace(NEWLINES_RE, '\\n'); // Replace tabs with proper number of spaces (1..4)\n\n  if (str.indexOf('\\t') >= 0) {\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\n      var result;\n\n      if (str.charCodeAt(offset) === 0x0A) {\n        lineStart = offset + 1;\n        lastTabPos = 0;\n        return match;\n      }\n\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n      lastTabPos = offset - lineStart + 1;\n      return result;\n    });\n  }\n\n  state = new StateBlock(str, this, options, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\n/**\n * Expose `ParserBlock`\n */\n\n\nmodule.exports = ParserBlock;","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/remarkable/lib/parser_block.js"],"names":["Ruler","require","StateBlock","_rules","ParserBlock","ruler","i","length","push","alt","slice","prototype","tokenize","state","startLine","endLine","rules","getRules","len","line","hasEmptyLines","ok","skipEmptyLines","tShift","blkIndent","tight","isEmpty","parentType","TABS_SCAN_RE","NEWLINES_RE","SPACES_RE","parse","str","options","env","outTokens","lineStart","lastTabPos","replace","indexOf","match","offset","result","charCodeAt","lineMax","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Local dependencies\n */\n\nvar Ruler      = require('./ruler');\nvar StateBlock = require('./rules_block/state_block');\n\n/**\n * Parser rules\n */\n\nvar _rules = [\n  [ 'code',       require('./rules_block/code') ],\n  [ 'fences',     require('./rules_block/fences'),     [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'blockquote' ] ],\n  [ 'footnote',   require('./rules_block/footnote'),   [ 'paragraph' ] ],\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'blockquote' ] ],\n  [ 'lheading',   require('./rules_block/lheading') ],\n  [ 'htmlblock',  require('./rules_block/htmlblock'),  [ 'paragraph', 'blockquote' ] ],\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph' ] ],\n  [ 'deflist',    require('./rules_block/deflist'),    [ 'paragraph' ] ],\n  [ 'paragraph',  require('./rules_block/paragraph') ]\n];\n\n/**\n * Block Parser class\n *\n * @api private\n */\n\nfunction ParserBlock() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], {\n      alt: (_rules[i][2] || []).slice()\n    });\n  }\n}\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n * @param  {Number} `startLine`\n * @param  {Number} `endLine`\n * @api private\n */\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var line = startLine;\n  var hasEmptyLines = false;\n  var ok, i;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) {\n      break;\n    }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.tShift[line] < state.blkIndent) {\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) {\n        break;\n      }\n    }\n\n    // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n\n      // two empty lines should stop the parser in list mode\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }\n      state.line = line;\n    }\n  }\n};\n\nvar TABS_SCAN_RE = /[\\n\\t]/g;\nvar NEWLINES_RE  = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar SPACES_RE    = /\\u00a0/g;\n\n/**\n * Tokenize the given `str`.\n *\n * @param  {String} `str` Source string\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserBlock.prototype.parse = function (str, options, env, outTokens) {\n  var state, lineStart = 0, lastTabPos = 0;\n  if (!str) { return []; }\n\n  // Normalize spaces\n  str = str.replace(SPACES_RE, ' ');\n\n  // Normalize newlines\n  str = str.replace(NEWLINES_RE, '\\n');\n\n  // Replace tabs with proper number of spaces (1..4)\n  if (str.indexOf('\\t') >= 0) {\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\n      var result;\n      if (str.charCodeAt(offset) === 0x0A) {\n        lineStart = offset + 1;\n        lastTabPos = 0;\n        return match;\n      }\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n      lastTabPos = offset - lineStart + 1;\n      return result;\n    });\n  }\n\n  state = new StateBlock(str, this, options, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n/**\n * Expose `ParserBlock`\n */\n\nmodule.exports = ParserBlock;\n"]},"metadata":{},"sourceType":"script"}