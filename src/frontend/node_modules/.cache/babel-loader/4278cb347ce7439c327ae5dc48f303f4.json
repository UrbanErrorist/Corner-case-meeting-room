{"ast":null,"code":"// Parse abbreviation definitions, i.e. `*[abbr]: description`\n//\n'use strict';\n\nvar StateInline = require('../rules_inline/state_inline');\n\nvar parseLinkLabel = require('../helpers/parse_link_label');\n\nfunction parseAbbr(str, parserInline, options, env) {\n  var state, labelEnd, pos, max, label, title;\n\n  if (str.charCodeAt(0) !== 0x2A\n  /* * */\n  ) {\n      return -1;\n    }\n\n  if (str.charCodeAt(1) !== 0x5B\n  /* [ */\n  ) {\n      return -1;\n    }\n\n  if (str.indexOf(']:') === -1) {\n    return -1;\n  }\n\n  state = new StateInline(str, parserInline, options, env, []);\n  labelEnd = parseLinkLabel(state, 1);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A\n  /* : */\n  ) {\n      return -1;\n    }\n\n  max = state.posMax; // abbr title is always one line, so looking for ending \"\\n\" here\n\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x0A) {\n      break;\n    }\n  }\n\n  label = str.slice(2, labelEnd);\n  title = str.slice(labelEnd + 2, pos).trim();\n\n  if (title.length === 0) {\n    return -1;\n  }\n\n  if (!env.abbreviations) {\n    env.abbreviations = {};\n  } // prepend ':' to avoid conflict with Object.prototype members\n\n\n  if (typeof env.abbreviations[':' + label] === 'undefined') {\n    env.abbreviations[':' + label] = title;\n  }\n\n  return pos;\n}\n\nmodule.exports = function abbr(state) {\n  var tokens = state.tokens,\n      i,\n      l,\n      content,\n      pos;\n\n  if (state.inlineMode) {\n    return;\n  } // Parse inlines\n\n\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i - 1].type === 'paragraph_open' && tokens[i].type === 'inline' && tokens[i + 1].type === 'paragraph_close') {\n      content = tokens[i].content;\n\n      while (content.length) {\n        pos = parseAbbr(content, state.inline, state.options, state.env);\n\n        if (pos < 0) {\n          break;\n        }\n\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Users/blackhat/TV Shows/Meeting Room/src/frontend/node_modules/remarkable/lib/rules_core/abbr.js"],"names":["StateInline","require","parseLinkLabel","parseAbbr","str","parserInline","options","env","state","labelEnd","pos","max","label","title","charCodeAt","indexOf","posMax","src","slice","trim","length","abbreviations","module","exports","abbr","tokens","i","l","content","inlineMode","type","inline","tight"],"mappings":"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","sourcesContent":["// Parse abbreviation definitions, i.e. `*[abbr]: description`\n//\n\n'use strict';\n\n\nvar StateInline    = require('../rules_inline/state_inline');\nvar parseLinkLabel = require('../helpers/parse_link_label');\n\n\nfunction parseAbbr(str, parserInline, options, env) {\n  var state, labelEnd, pos, max, label, title;\n\n  if (str.charCodeAt(0) !== 0x2A/* * */) { return -1; }\n  if (str.charCodeAt(1) !== 0x5B/* [ */) { return -1; }\n\n  if (str.indexOf(']:') === -1) { return -1; }\n\n  state = new StateInline(str, parserInline, options, env, []);\n  labelEnd = parseLinkLabel(state, 1);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n  max = state.posMax;\n\n  // abbr title is always one line, so looking for ending \"\\n\" here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x0A) { break; }\n  }\n\n  label = str.slice(2, labelEnd);\n  title = str.slice(labelEnd + 2, pos).trim();\n  if (title.length === 0) { return -1; }\n  if (!env.abbreviations) { env.abbreviations = {}; }\n  // prepend ':' to avoid conflict with Object.prototype members\n  if (typeof env.abbreviations[':' + label] === 'undefined') {\n    env.abbreviations[':' + label] = title;\n  }\n\n  return pos;\n}\n\nmodule.exports = function abbr(state) {\n  var tokens = state.tokens, i, l, content, pos;\n\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Parse inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i - 1].type === 'paragraph_open' &&\n        tokens[i].type === 'inline' &&\n        tokens[i + 1].type === 'paragraph_close') {\n\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseAbbr(content, state.inline, state.options, state.env);\n        if (pos < 0) { break; }\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}