{"ast":null,"code":"// Definition lists\n'use strict'; // Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\n\nfunction skipMarker(state, line) {\n  var pos,\n      marker,\n      start = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n\n  if (start >= max) {\n    return -1;\n  } // Check bullet\n\n\n  marker = state.src.charCodeAt(start++);\n\n  if (marker !== 0x7E\n  /* ~ */\n  && marker !== 0x3A\n  /* : */\n  ) {\n      return -1;\n    }\n\n  pos = state.skipSpaces(start); // require space after \":\"\n\n  if (start === pos) {\n    return -1;\n  } // no empty definitions, e.g. \"  : \"\n\n\n  if (pos >= max) {\n    return -1;\n  }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i,\n      l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nmodule.exports = function deflist(state, startLine, endLine, silent) {\n  var contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, nextLine, oldIndent, oldDDIndent, oldParentType, oldTShift, oldTight, prevEmptyEnd, tight;\n\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole deflist\n    if (state.ddIndent < 0) {\n      return false;\n    }\n\n    return skipMarker(state, startLine) >= 0;\n  }\n\n  nextLine = startLine + 1;\n\n  if (state.isEmpty(nextLine)) {\n    if (++nextLine > endLine) {\n      return false;\n    }\n  }\n\n  if (state.tShift[nextLine] < state.blkIndent) {\n    return false;\n  }\n\n  contentStart = skipMarker(state, nextLine);\n\n  if (contentStart < 0) {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // Start list\n\n\n  listTokIdx = state.tokens.length;\n  state.tokens.push({\n    type: 'dl_open',\n    lines: listLines = [startLine, 0],\n    level: state.level++\n  }); //\n  // Iterate list items\n  //\n\n  dtLine = startLine;\n  ddLine = nextLine; // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n\n  /*eslint no-labels:0,block-scoped-var:0*/\n\n  OUTER: for (;;) {\n    tight = true;\n    prevEmptyEnd = false;\n    state.tokens.push({\n      type: 'dt_open',\n      lines: [dtLine, dtLine],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n      level: state.level + 1,\n      lines: [dtLine, dtLine],\n      children: []\n    });\n    state.tokens.push({\n      type: 'dt_close',\n      level: --state.level\n    });\n\n    for (;;) {\n      state.tokens.push({\n        type: 'dd_open',\n        lines: itemLines = [nextLine, 0],\n        level: state.level++\n      });\n      oldTight = state.tight;\n      oldDDIndent = state.ddIndent;\n      oldIndent = state.blkIndent;\n      oldTShift = state.tShift[ddLine];\n      oldParentType = state.parentType;\n      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.tight = true;\n      state.parentType = 'deflist';\n      state.parser.tokenize(state, ddLine, endLine, true); // If any of list item is tight, mark list as tight\n\n      if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      } // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n\n\n      prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);\n      state.tShift[ddLine] = oldTShift;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n      state.tokens.push({\n        type: 'dd_close',\n        level: --state.level\n      });\n      itemLines[1] = nextLine = state.line;\n\n      if (nextLine >= endLine) {\n        break OUTER;\n      }\n\n      if (state.tShift[nextLine] < state.blkIndent) {\n        break OUTER;\n      }\n\n      contentStart = skipMarker(state, nextLine);\n\n      if (contentStart < 0) {\n        break;\n      }\n\n      ddLine = nextLine; // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n\n    if (nextLine >= endLine) {\n      break;\n    }\n\n    dtLine = nextLine;\n\n    if (state.isEmpty(dtLine)) {\n      break;\n    }\n\n    if (state.tShift[dtLine] < state.blkIndent) {\n      break;\n    }\n\n    ddLine = dtLine + 1;\n\n    if (ddLine >= endLine) {\n      break;\n    }\n\n    if (state.isEmpty(ddLine)) {\n      ddLine++;\n    }\n\n    if (ddLine >= endLine) {\n      break;\n    }\n\n    if (state.tShift[ddLine] < state.blkIndent) {\n      break;\n    }\n\n    contentStart = skipMarker(state, ddLine);\n\n    if (contentStart < 0) {\n      break;\n    } // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n\n  } // Finilize list\n\n\n  state.tokens.push({\n    type: 'dl_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n  state.line = nextLine; // mark paragraphs tight if needed\n\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/Users/blackhat/Desktop/testingRoom/src/frontend/node_modules/remarkable/lib/rules_block/deflist.js"],"names":["skipMarker","state","line","pos","marker","start","bMarks","tShift","max","eMarks","src","charCodeAt","skipSpaces","markTightParagraphs","idx","i","l","level","tokens","length","type","tight","module","exports","deflist","startLine","endLine","silent","contentStart","ddLine","dtLine","itemLines","listLines","listTokIdx","nextLine","oldIndent","oldDDIndent","oldParentType","oldTShift","oldTight","prevEmptyEnd","ddIndent","isEmpty","blkIndent","options","maxNesting","push","lines","OUTER","content","getLines","trim","children","parentType","parser","tokenize"],"mappings":"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","sourcesContent":["// Definition lists\n\n'use strict';\n\n\n// Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipMarker(state, line) {\n  var pos, marker,\n      start = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n\n  if (start >= max) { return -1; }\n\n  // Check bullet\n  marker = state.src.charCodeAt(start++);\n  if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }\n\n  pos = state.skipSpaces(start);\n\n  // require space after \":\"\n  if (start === pos) { return -1; }\n\n  // no empty definitions, e.g. \"  : \"\n  if (pos >= max) { return -1; }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nmodule.exports = function deflist(state, startLine, endLine, silent) {\n  var contentStart,\n      ddLine,\n      dtLine,\n      itemLines,\n      listLines,\n      listTokIdx,\n      nextLine,\n      oldIndent,\n      oldDDIndent,\n      oldParentType,\n      oldTShift,\n      oldTight,\n      prevEmptyEnd,\n      tight;\n\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole deflist\n    if (state.ddIndent < 0) { return false; }\n    return skipMarker(state, startLine) >= 0;\n  }\n\n  nextLine = startLine + 1;\n  if (state.isEmpty(nextLine)) {\n    if (++nextLine > endLine) { return false; }\n  }\n\n  if (state.tShift[nextLine] < state.blkIndent) { return false; }\n  contentStart = skipMarker(state, nextLine);\n  if (contentStart < 0) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  state.tokens.push({\n    type: 'dl_open',\n    lines: listLines = [ startLine, 0 ],\n    level: state.level++\n  });\n\n  //\n  // Iterate list items\n  //\n\n  dtLine = startLine;\n  ddLine = nextLine;\n\n  // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n  /*eslint no-labels:0,block-scoped-var:0*/\n  OUTER:\n  for (;;) {\n    tight = true;\n    prevEmptyEnd = false;\n\n    state.tokens.push({\n      type: 'dt_open',\n      lines: [ dtLine, dtLine ],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n      level: state.level + 1,\n      lines: [ dtLine, dtLine ],\n      children: []\n    });\n    state.tokens.push({\n      type: 'dt_close',\n      level: --state.level\n    });\n\n    for (;;) {\n      state.tokens.push({\n        type: 'dd_open',\n        lines: itemLines = [ nextLine, 0 ],\n        level: state.level++\n      });\n\n      oldTight = state.tight;\n      oldDDIndent = state.ddIndent;\n      oldIndent = state.blkIndent;\n      oldTShift = state.tShift[ddLine];\n      oldParentType = state.parentType;\n      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.tight = true;\n      state.parentType = 'deflist';\n\n      state.parser.tokenize(state, ddLine, endLine, true);\n\n      // If any of list item is tight, mark list as tight\n      if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      }\n      // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n      prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);\n\n      state.tShift[ddLine] = oldTShift;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n\n      state.tokens.push({\n        type: 'dd_close',\n        level: --state.level\n      });\n\n      itemLines[1] = nextLine = state.line;\n\n      if (nextLine >= endLine) { break OUTER; }\n\n      if (state.tShift[nextLine] < state.blkIndent) { break OUTER; }\n      contentStart = skipMarker(state, nextLine);\n      if (contentStart < 0) { break; }\n\n      ddLine = nextLine;\n\n      // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n\n    if (nextLine >= endLine) { break; }\n    dtLine = nextLine;\n\n    if (state.isEmpty(dtLine)) { break; }\n    if (state.tShift[dtLine] < state.blkIndent) { break; }\n\n    ddLine = dtLine + 1;\n    if (ddLine >= endLine) { break; }\n    if (state.isEmpty(ddLine)) { ddLine++; }\n    if (ddLine >= endLine) { break; }\n\n    if (state.tShift[ddLine] < state.blkIndent) { break; }\n    contentStart = skipMarker(state, ddLine);\n    if (contentStart < 0) { break; }\n\n    // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: 'dl_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}