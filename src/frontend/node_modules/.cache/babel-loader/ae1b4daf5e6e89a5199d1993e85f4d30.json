{"ast":null,"code":"// Lists\n'use strict'; // Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\n\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max;\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  if (pos >= max) {\n    return -1;\n  }\n\n  marker = state.src.charCodeAt(pos++); // Check bullet\n\n  if (marker !== 0x2A\n  /* * */\n  && marker !== 0x2D\n  /* - */\n  && marker !== 0x2B\n  /* + */\n  ) {\n      return -1;\n    }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n\n  return pos;\n} // Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\n\n\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 1 >= max) {\n    return -1;\n  }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30\n  /* 0 */\n  || ch > 0x39\n  /* 9 */\n  ) {\n      return -1;\n    }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) {\n      return -1;\n    }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30\n    /* 0 */\n    && ch <= 0x39\n    /* 9 */\n    ) {\n        continue;\n      } // found valid marker\n\n\n    if (ch === 0x29\n    /* ) */\n    || ch === 0x2e\n    /* . */\n    ) {\n        break;\n      }\n\n    return -1;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20\n  /* space */\n  ) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i,\n      l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var nextLine,\n      indent,\n      oldTShift,\n      oldIndent,\n      oldTight,\n      oldParentType,\n      start,\n      posAfterMarker,\n      max,\n      indentAfterMarker,\n      markerValue,\n      markerCharCode,\n      isOrdered,\n      contentStart,\n      listTokIdx,\n      prevEmptyEnd,\n      listLines,\n      itemLines,\n      tight = true,\n      terminatorRules,\n      i,\n      l,\n      terminate; // Detect list type and position after marker\n\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // We should terminate list on style change. Remember first one to compare.\n\n\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1); // For validation mode we can terminate immediately\n\n  if (silent) {\n    return true;\n  } // Start list\n\n\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n    state.tokens.push({\n      type: 'ordered_list_open',\n      order: markerValue,\n      lines: listLines = [startLine, 0],\n      level: state.level++\n    });\n  } else {\n    state.tokens.push({\n      type: 'bullet_list_open',\n      lines: listLines = [startLine, 0],\n      level: state.level++\n    });\n  } //\n  // Iterate list items\n  //\n\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.parser.ruler.getRules('list');\n\n  while (nextLine < endLine) {\n    contentStart = state.skipSpaces(posAfterMarker);\n    max = state.eMarks[nextLine];\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = contentStart - posAfterMarker;\n    } // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n\n\n    if (indentAfterMarker > 4) {\n      indentAfterMarker = 1;\n    } // If indent is less than 1, assume that it's one, example:\n    //  \"-\\n  test\"\n\n\n    if (indentAfterMarker < 1) {\n      indentAfterMarker = 1;\n    } // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n\n\n    indent = posAfterMarker - state.bMarks[nextLine] + indentAfterMarker; // Run subparser & write tokens\n\n    state.tokens.push({\n      type: 'list_item_open',\n      lines: itemLines = [startLine, 0],\n      level: state.level++\n    });\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldParentType = state.parentType;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.parentType = 'list';\n    state.parser.tokenize(state, startLine, endLine, true); // If any of list item is tight, mark list as tight\n\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    } // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n\n\n    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.tight = oldTight;\n    state.parentType = oldParentType;\n    state.tokens.push({\n      type: 'list_item_close',\n      level: --state.level\n    });\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) {\n      break;\n    }\n\n    if (state.isEmpty(nextLine)) {\n      break;\n    } //\n    // Try to check if list is terminated or continued.\n    //\n\n\n    if (state.tShift[nextLine] < state.blkIndent) {\n      break;\n    } // fail if terminating block found\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    } // fail if list has another type\n\n\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n      break;\n    }\n  } // Finilize list\n\n\n  state.tokens.push({\n    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n  state.line = nextLine; // mark paragraphs tight if needed\n\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/Users/blackhat/Desktop/testingRoom/src/frontend/node_modules/remarkable/lib/rules_block/list.js"],"names":["skipBulletListMarker","state","startLine","marker","pos","max","bMarks","tShift","eMarks","src","charCodeAt","skipOrderedListMarker","ch","markTightParagraphs","idx","i","l","level","tokens","length","type","tight","module","exports","list","endLine","silent","nextLine","indent","oldTShift","oldIndent","oldTight","oldParentType","start","posAfterMarker","indentAfterMarker","markerValue","markerCharCode","isOrdered","contentStart","listTokIdx","prevEmptyEnd","listLines","itemLines","terminatorRules","terminate","options","maxNesting","Number","substr","push","order","lines","parser","ruler","getRules","skipSpaces","blkIndent","parentType","tokenize","line","isEmpty"],"mappings":"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","sourcesContent":["// Lists\n\n'use strict';\n\n\n// Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  if (pos >= max) { return -1; }\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var nextLine,\n      indent,\n      oldTShift,\n      oldIndent,\n      oldTight,\n      oldParentType,\n      start,\n      posAfterMarker,\n      max,\n      indentAfterMarker,\n      markerValue,\n      markerCharCode,\n      isOrdered,\n      contentStart,\n      listTokIdx,\n      prevEmptyEnd,\n      listLines,\n      itemLines,\n      tight = true,\n      terminatorRules,\n      i, l, terminate;\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n    state.tokens.push({\n      type: 'ordered_list_open',\n      order: markerValue,\n      lines: listLines = [ startLine, 0 ],\n      level: state.level++\n    });\n\n  } else {\n    state.tokens.push({\n      type: 'bullet_list_open',\n      lines: listLines = [ startLine, 0 ],\n      level: state.level++\n    });\n  }\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.parser.ruler.getRules('list');\n\n  while (nextLine < endLine) {\n    contentStart = state.skipSpaces(posAfterMarker);\n    max = state.eMarks[nextLine];\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = contentStart - posAfterMarker;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // If indent is less than 1, assume that it's one, example:\n    //  \"-\\n  test\"\n    if (indentAfterMarker < 1) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;\n\n    // Run subparser & write tokens\n    state.tokens.push({\n      type: 'list_item_open',\n      lines: itemLines = [ startLine, 0 ],\n      level: state.level++\n    });\n\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldParentType = state.parentType;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.parentType = 'list';\n\n    state.parser.tokenize(state, startLine, endLine, true);\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.tight = oldTight;\n    state.parentType = oldParentType;\n\n    state.tokens.push({\n      type: 'list_item_close',\n      level: --state.level\n    });\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    if (state.isEmpty(nextLine)) {\n      break;\n    }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.tShift[nextLine] < state.blkIndent) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}